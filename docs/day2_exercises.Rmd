---
title: '<span class="en">Day 2: Exercises</span><span class="de">Tag 2: √úbungen</span>'
subtitle: '<span class="en">Advanced Analysis & Research Project</span><span class="de">Fortgeschrittene Analyse & Forschungsprojekt</span>'
author: '<span class="en">Fill in the blanks!</span><span class="de">F√ºlle die L√ºcken aus!</span>'
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: flatly
    self_contained: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, message = FALSE, warning = FALSE)
```

```{=html}
<style>
/* ========== PLAYFUL WORKSHOP THEME ========== */

body {
 font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
 line-height: 1.7;
 background-color: #fafffe;
}

h1 {
 color: #2E7D32 !important;
 border-bottom: 3px solid #4CAF50;
 padding-bottom: 10px;
}

h2 {
 color: #388E3C !important;
 margin-top: 2em;
}

h3 {
 color: #43A047 !important;
}

h4 {
 color: #66BB6A !important;
 border-left: 4px solid #4CAF50;
 padding-left: 10px;
}

/* Code blocks with copy button support */
pre {
 background-color: #f5f5f5 !important;
 border-left: 4px solid #4CAF50 !important;
 padding: 15px;
 padding-top: 35px;
 border-radius: 8px;
 overflow-x: auto;
 position: relative !important;
}

code {
 background-color: #E8F5E9;
 padding: 2px 6px;
 border-radius: 4px;
 color: #2E7D32;
}

pre code {
 background-color: transparent;
 padding: 0;
}

/* Copy button styling */
.copy-btn {
 position: absolute !important;
 top: 8px !important;
 right: 8px !important;
 padding: 4px 12px;
 font-size: 12px;
 background: #4CAF50;
 color: white;
 border: none;
 border-radius: 4px;
 cursor: pointer;
 opacity: 0;
 transition: opacity 0.2s, background 0.2s;
 z-index: 100;
}

pre:hover .copy-btn {
 opacity: 1;
}

.copy-btn:hover {
 background: #2E7D32;
}

.copy-btn.copied {
 background: #1976D2;
}

blockquote {
 border-left: 4px solid #FF9800;
 background-color: #FFF8E1;
 padding: 15px 20px;
 margin: 1em 0;
 border-radius: 0 8px 8px 0;
}

hr {
 border: none;
 height: 3px;
 background: linear-gradient(to right, #4CAF50, #81C784, #C8E6C9, #81C784, #4CAF50);
 margin: 2em 0;
 border-radius: 2px;
}

.tocify {
 border: none !important;
 border-radius: 12px !important;
 background-color: #f1f8e9 !important;
 box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.tocify-item.active, .tocify-item.active:hover {
 background-color: #4CAF50 !important;
 color: white !important;
}

/* Exercise hint */
.hint {
 background-color: #E3F2FD;
 border: 1px solid #1976D2;
 border-radius: 8px;
 padding: 10px 15px;
 margin: 1em 0;
 font-size: 0.9em;
}

.hint::before {
 content: "üí° ";
}

/* Explore box */
.explore {
 background-color: #FFF3E0;
 border: 1px solid #FF9800;
 border-radius: 8px;
 padding: 10px 15px;
 margin: 1em 0;
 font-size: 0.9em;
}

.explore::before {
 content: "üîç ";
}

/* Debug box */
.debug {
 background-color: #FFEBEE;
 border: 1px solid #F44336;
 border-radius: 8px;
 padding: 10px 15px;
 margin: 1em 0;
 font-size: 0.9em;
}

.debug::before {
 content: "üêõ ";
}

/* Predict box */
.predict {
 background-color: #E8F5E9;
 border: 1px solid #4CAF50;
 border-radius: 8px;
 padding: 10px 15px;
 margin: 1em 0;
 font-size: 0.9em;
}

.predict::before {
 content: "ü§î ";
}

/* ========== LANGUAGE TOGGLE ========== */

.lang-toggle {
 position: fixed;
 top: 10px;
 right: 20px;
 z-index: 9999;
 background: linear-gradient(135deg, #2E7D32, #4CAF50);
 padding: 8px 12px;
 border-radius: 25px;
 box-shadow: 0 4px 15px rgba(46, 125, 50, 0.3);
}

.lang-toggle button {
 background: transparent;
 border: none;
 color: #fff;
 padding: 6px 14px;
 cursor: pointer;
 font-weight: bold;
 border-radius: 20px;
 transition: all 0.3s;
 font-size: 14px;
}

.lang-toggle button.active {
 background: white;
 color: #2E7D32;
}

.lang-toggle button:hover:not(.active) {
 background: rgba(255,255,255,0.2);
}

.de { display: none; }
.en { display: inline; }

body.lang-de .de { display: inline; }
body.lang-de .en { display: none; }

div.de, p.de, li.de, h1.de, h2.de, h3.de, h4.de, section.de { display: none; }
div.en, p.en, li.en, h1.en, h2.en, h3.en, h4.en, section.en { display: block; }

body.lang-de div.de, body.lang-de p.de, body.lang-de li.de,
body.lang-de h1.de, body.lang-de h2.de, body.lang-de h3.de,
body.lang-de h4.de, body.lang-de section.de { display: block; }

body.lang-de div.en, body.lang-de p.en, body.lang-de li.en,
body.lang-de h1.en, body.lang-de h2.en, body.lang-de h3.en,
body.lang-de h4.en, body.lang-de section.en { display: none; }

body.lang-de #TOC .en { display: none; }
body.lang-de #TOC .de { display: inline; }
#TOC .de { display: none; }
#TOC .en { display: inline; }

@media print {
 .tocify, .lang-toggle, .copy-btn { display: none; }
}

/* ========== MOBILE RESPONSIVE ========== */
@media (max-width: 768px) {
  body { font-size: 14px; line-height: 1.5; }
  h1 { font-size: 1.5rem; }
  h2 { font-size: 1.3rem; }
  h3 { font-size: 1.1rem; }
  .lang-toggle { top: 5px; right: 10px; padding: 5px 8px; }
  .lang-toggle button { padding: 4px 10px; font-size: 12px; }
  table { font-size: 12px; display: block; overflow-x: auto; white-space: nowrap; }
  th, td { padding: 6px 8px; }
  blockquote { padding: 10px 15px; margin: 0.5em 0; }
  pre { font-size: 11px; padding: 10px; }
  code { font-size: 11px; }
  img, .figure img { max-width: 100%; height: auto; }
  .code-exercise { padding: 10px; }
}
</style>
```

```{=html}
<script>
$(document).ready(function() {
  // Language toggle
  var toggle = $('<div class="lang-toggle"><button id="btn-en" class="active">EN</button><button id="btn-de">DE</button></div>');
  $('body').append(toggle);

  var savedLang = localStorage.getItem('workshop-lang');
  var browserLang = navigator.language.substring(0, 2);
  var defaultLang = savedLang || (browserLang === 'de' ? 'de' : 'en');

  function setLanguage(lang) {
    $('body').removeClass('lang-en lang-de').addClass('lang-' + lang);
    $('#btn-en').toggleClass('active', lang === 'en');
    $('#btn-de').toggleClass('active', lang === 'de');
    localStorage.setItem('workshop-lang', lang);
  }

  if (defaultLang === 'de') {
    setLanguage('de');
  }

  $('#btn-en').click(function() { setLanguage('en'); });
  $('#btn-de').click(function() { setLanguage('de'); });

  // Copy button for code blocks
  $('pre').each(function() {
    var pre = $(this);
    var btn = $('<button class="copy-btn">Copy</button>');

    btn.click(function() {
      var code = pre.find('code');
      var text = code.length ? code.text() : pre.text();

      function showSuccess() {
        btn.text('Copied!').addClass('copied');
        setTimeout(function() {
          btn.text('Copy').removeClass('copied');
        }, 2000);
      }

      function fallbackCopy() {
        var textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        try {
          document.execCommand('copy');
          showSuccess();
        } catch(e) {
          btn.text('Failed');
        }
        document.body.removeChild(textarea);
      }

      // Use clipboard API if available and in secure context, else fallback
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text).then(showSuccess).catch(fallbackCopy);
      } else {
        fallbackCopy();
      }
    });

    pre.css('position', 'relative').append(btn);
  });
});
</script>
```

---

# <span class="en">Part 2: Advanced Analysis - Welcome to Day 2!</span><span class="de">Teil 2: Fortgeschrittene Analyse - Willkommen zu Tag 2!</span>

<div class="en">

Yesterday you built your first species accumulation curve. Today we'll take it to the next level with real scientific analysis!

**What you'll learn today:**

1. **Spatial sampling** - Walk through plots like a real field ecologist
2. **Measuring uncertainty** - Run from multiple starting points
3. **Comparing natives vs aliens** - Do they accumulate differently?
4. **Publication-quality figures** - Make plots ready for a research paper

**How to use these exercises:**

- Replace each `____` with the correct code
- Run each chunk to see if it works
- Read the hints if you get stuck
- The exercises build on each other - do them in order!

</div>

<div class="de">

Gestern hast du deine erste Artenakkumulationskurve gebaut. Heute bringen wir es mit echter wissenschaftlicher Analyse auf das n√§chste Level!

**Was du heute lernst:**

1. **R√§umliche Probenahme** - Gehe durch Plots wie ein echter Feld√∂kologe
2. **Unsicherheit messen** - Starte von mehreren Punkten
3. **Heimische vs Aliens vergleichen** - Akkumulieren sie unterschiedlich?
4. **Publikationsreife Abbildungen** - Erstelle Plots bereit f√ºr eine Forschungsarbeit

**So verwendest du diese √úbungen:**

- Ersetze jedes `____` mit dem richtigen Code
- F√ºhre jeden Chunk aus um zu sehen ob er funktioniert
- Lies die Hinweise wenn du nicht weiterkommst
- Die √úbungen bauen aufeinander auf - mache sie der Reihe nach!

</div>

---

# <span class="en">Exercise 1: Setup - Load Data and Functions</span><span class="de">√úbung 1: Setup - Daten und Funktionen laden</span>

<div class="en">

**Concept:** Before we start, we need to load our data and define some helper functions. These functions will make our analysis easier.

</div>

<div class="de">

**Konzept:** Bevor wir beginnen, m√ºssen wir unsere Daten laden und einige Hilfsfunktionen definieren. Diese Funktionen machen unsere Analyse einfacher.

</div>

### <span class="en">1a: Load packages and data</span><span class="de">1a: Pakete und Daten laden</span>

```{r}
# Load packages
# Pakete laden
library(tidyverse)

# Load data
# Daten laden
header <- read_csv("../data/austria_header.csv")
species <- read_csv("../data/austria_species.csv")

# Check data loaded correctly
# √úberpr√ºfe dass Daten korrekt geladen sind
cat("Plots loaded:", nrow(header), "\n")
cat("Species records:", nrow(species), "\n")
cat("Unique species:", length(unique(species$WFO_TAXON)), "\n")
```

### <span class="en">1b: Define helper functions</span><span class="de">1b: Hilfsfunktionen definieren</span>

```{r}
# Distance function - calculates distance between two points
# Distanzfunktion - berechnet Abstand zwischen zwei Punkten
calc_distance <- function(x1, y1, x2, y2) {
  sqrt((x2 - x1)^2 + (y2 - y1)^2)
}

# Nearest-neighbour walk - visits plots by always going to closest unvisited
# Nearest-Neighbour-Walk - besucht Plots indem immer zum n√§chsten unbesuchten gegangen wird
nn_walk <- function(header_data, start_idx = NULL) {
  n <- nrow(header_data)
  if (is.null(start_idx)) start_idx <- sample(1:n, 1)

  visited <- rep(FALSE, n)
  visit_order <- numeric(n)
  current <- start_idx

  for (i in 1:n) {
    visited[current] <- TRUE
    visit_order[i] <- header_data$PlotObservationID[current]

    if (i < n) {
      distances <- calc_distance(
        header_data$Longitude[current], header_data$Latitude[current],
        header_data$Longitude, header_data$Latitude
      )
      distances[visited] <- Inf
      current <- which.min(distances)
    }
  }
  return(visit_order)
}

# Build accumulation curve for given plot order
# Baue Akkumulationskurve f√ºr gegebene Plot-Reihenfolge
build_accumulation <- function(species_data, plot_order, status_filter = NULL) {
  if (!is.null(status_filter)) {
    species_data <- species_data %>% filter(STATUS == status_filter)
  }

  found <- c()
  accum <- numeric(length(plot_order))

  for (i in seq_along(plot_order)) {
    plot_spp <- species_data %>%
      filter(PlotObservationID == plot_order[i]) %>%
      pull(WFO_TAXON) %>%
      unique()

    new_spp <- setdiff(plot_spp, found)
    found <- c(found, new_spp)
    accum[i] <- length(found)
  }
  return(accum)
}

# Find saturation point (when we reach X% of total species)
# Finde S√§ttigungspunkt (wenn wir X% der Gesamtarten erreichen)
find_saturation <- function(curve, threshold = 0.8) {
  target <- max(curve) * threshold
  which(curve >= target)[1]
}

cat("All functions loaded!\n")
```

<div class="hint">
<span class="en">Hint: Run both code blocks above. If you get errors, check that the data files exist in `../data/`.</span>
<span class="de">Hinweis: F√ºhre beide Code-Bl√∂cke aus. Bei Fehlern pr√ºfe ob die Dateien in `../data/` existieren.</span>
</div>

```{=html}
<!-- Hidden Rcpp section - only visible when toggled -->
<style>
.rcpp-section {
  display: none;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #e94560;
  border-radius: 12px;
  padding: 20px;
  margin: 1.5em 0;
  color: #eee;
}
.rcpp-section.visible { display: block; }
.rcpp-section h4 { color: #e94560 !important; border: none; margin-top: 0; }
.rcpp-section code { background-color: #0f3460; color: #00ff88; }
.rcpp-section pre { background-color: #0f3460 !important; border-left-color: #e94560 !important; }
.rcpp-section pre code { color: #00ff88; }
.rcpp-toggle {
  background: linear-gradient(135deg, #e94560, #c23a5a);
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  font-weight: bold;
  font-size: 12px;
  margin: 0.5em 0;
}
.rcpp-toggle:hover { background: linear-gradient(135deg, #c23a5a, #a02040); }
</style>

<button class="rcpp-toggle" onclick="document.getElementById('rcpp-turbo').classList.toggle('visible')">
  ‚ö° Turbo Mode: Show/Hide Rcpp Functions
</button>

<div id="rcpp-turbo" class="rcpp-section">
<h4>‚ö° Rcpp Turbo Functions (if R is too slow)</h4>

<p><span class="en">If analyses take too long, these C++ versions are 10-50x faster. Run this ONCE at the start to replace the R functions:</span><span class="de">Falls Analysen zu lange dauern, sind diese C++ Versionen 10-50x schneller. F√ºhre dies EINMAL am Anfang aus um die R-Funktionen zu ersetzen:</span></p>

<pre><code class="r"># Install Rcpp if needed / Installiere Rcpp falls n√∂tig
# install.packages("Rcpp")
library(Rcpp)

# Compile the C++ functions / Kompiliere die C++ Funktionen
cppFunction('
NumericVector nn_walk_cpp(NumericVector lon, NumericVector lat, IntegerVector plot_ids, int start_idx) {
  int n = lon.size();
  NumericVector visit_order(n);
  LogicalVector visited(n, false);

  int current = start_idx - 1;  // Convert to 0-indexed

  for (int i = 0; i < n; i++) {
    visited[current] = true;
    visit_order[i] = plot_ids[current];

    if (i < n - 1) {
      double min_dist = R_PosInf;
      int next_idx = -1;

      for (int j = 0; j < n; j++) {
        if (!visited[j]) {
          double dx = lon[j] - lon[current];
          double dy = lat[j] - lat[current];
          double dist = sqrt(dx*dx + dy*dy);
          if (dist < min_dist) {
            min_dist = dist;
            next_idx = j;
          }
        }
      }
      current = next_idx;
    }
  }
  return visit_order;
}
')

cppFunction('
IntegerVector build_accum_cpp(IntegerVector plot_obs_id, IntegerVector taxon_id,
                               IntegerVector plot_order) {
  int n_plots = plot_order.size();
  IntegerVector accum(n_plots);
  std::set<int> found_species;

  for (int i = 0; i < n_plots; i++) {
    int target_plot = plot_order[i];

    for (int j = 0; j < plot_obs_id.size(); j++) {
      if (plot_obs_id[j] == target_plot) {
        found_species.insert(taxon_id[j]);
      }
    }
    accum[i] = found_species.size();
  }
  return accum;
}
', includes = "#include <set>")

# Wrapper function for nn_walk (drop-in replacement)
# Wrapper-Funktion f√ºr nn_walk (direkter Ersatz)
nn_walk_fast <- function(header_data, start_idx = NULL) {
  if (is.null(start_idx)) start_idx <- sample(1:nrow(header_data), 1)
  nn_walk_cpp(header_data$Longitude, header_data$Latitude,
              header_data$PlotObservationID, start_idx)
}

# Wrapper for build_accumulation (requires pre-processing)
# Wrapper f√ºr build_accumulation (ben√∂tigt Vorverarbeitung)
build_accumulation_fast <- function(species_data, plot_order, status_filter = NULL) {
  if (!is.null(status_filter)) {
    species_data <- species_data[species_data$STATUS == status_filter, ]
  }
  # Convert taxon names to integers for speed
  taxon_factor <- as.integer(factor(species_data$WFO_TAXON))
  build_accum_cpp(species_data$PlotObservationID, taxon_factor, as.integer(plot_order))
}

# Replace the R functions / Ersetze die R-Funktionen
nn_walk <- nn_walk_fast
build_accumulation <- build_accumulation_fast

cat("‚ö° Rcpp turbo mode activated! Functions are now 10-50x faster.\n")
cat("‚ö° Rcpp Turbo-Modus aktiviert! Funktionen sind jetzt 10-50x schneller.\n")
</code></pre>

<p style="font-size: 0.85em; color: #aaa;"><span class="en">Note: Requires Rcpp package and a C++ compiler (Rtools on Windows).</span><span class="de">Hinweis: Ben√∂tigt Rcpp-Paket und einen C++ Compiler (Rtools unter Windows).</span></p>
</div>
```

---

# <span class="en">Exercise 2: Understanding Spatial Sampling</span><span class="de">√úbung 2: R√§umliche Probenahme verstehen</span>

<div class="en">

**Concept:** When we sample plots randomly, we might jump all over the map. But a **nearest-neighbour walk** samples like a real ecologist would - always going to the closest unvisited plot. This creates a realistic spatial accumulation curve.

</div>

<div class="de">

**Konzept:** Wenn wir Plots zuf√§llig sampeln, springen wir vielleicht √ºber die ganze Karte. Aber ein **Nearest-Neighbour-Walk** sampelt wie ein echter √ñkologe - geht immer zum n√§chsten unbesuchten Plot. Das erstellt eine realistische r√§umliche Akkumulationskurve.

</div>

### <span class="en">2a: Create a sample dataset</span><span class="de">2a: Erstelle einen Beispieldatensatz</span>

```{r}
# Take a random sample of 150 plots (for speed)
# Nimm eine zuf√§llige Stichprobe von 150 Plots (f√ºr Geschwindigkeit)
set.seed(42)  # For reproducibility / F√ºr Reproduzierbarkeit
sample_size <- 150

sample_ids <- sample(unique(header$PlotObservationID), sample_size)
sample_header <- header %>% filter(PlotObservationID %in% sample_ids)
sample_species <- species %>% filter(PlotObservationID %in% sample_ids)

cat("Sample created:", nrow(sample_header), "plots\n")
```

### <span class="en">2b: Run a nearest-neighbour walk</span><span class="de">2b: F√ºhre einen Nearest-Neighbour-Walk aus</span>

```{r}
# Start from plot 1 and walk to nearest neighbours
# Starte von Plot 1 und gehe zu n√§chsten Nachbarn
nn_order <- nn_walk(sample_header, start_idx = 1)

# Build curves for native and alien species
# Baue Kurven f√ºr heimische und Alien-Arten
native_curve <- build_accumulation(sample_species, nn_order, "____")
alien_curve <- build_accumulation(sample_species, nn_order, "____")

# Check the results
# √úberpr√ºfe die Ergebnisse
cat("Native species found:", max(native_curve), "\n")
cat("Alien species found:", max(alien_curve), "\n")
```

### <span class="en">2c: Plot the comparison</span><span class="de">2c: Plotte den Vergleich</span>

```{r}
# Create data frame for plotting
# Erstelle Data Frame zum Plotten
curve_data <- data.frame(
  plots = rep(1:sample_size, 2),
  species = c(native_curve, alien_curve),
  status = rep(c("Native", "Alien"), each = sample_size)
)

ggplot(curve_data, aes(x = plots, y = species, color = status)) +
  geom_line(linewidth = 1.2) +
  scale_color_manual(values = c("Native" = "darkgreen", "Alien" = "____")) +
  labs(
    title = "Native vs Alien Species Accumulation",
    x = "Plots Sampled (Nearest-Neighbour Order)",
    y = "Cumulative Species",
    color = ""
  ) +
  theme_minimal()
```

<div class="hint">
<span class="en">Hint: Native species use STATUS = "nat", alien species use STATUS = "neo".</span>
<span class="de">Hinweis: Heimische Arten haben STATUS = "nat", Alien-Arten haben STATUS = "neo".</span>
</div>

---

# <span class="en">Exercise 3: Measuring Uncertainty</span><span class="de">√úbung 3: Unsicherheit messen</span>

<div class="en">

**Concept:** The curve we get depends on WHERE we start! If we start in a native-rich area, natives accumulate fast. If we start near an alien hotspot, aliens accumulate fast. We need to run from MANY starting points to see the true pattern.

</div>

<div class="de">

**Konzept:** Die Kurve die wir bekommen h√§ngt davon ab WO wir starten! Starten wir in einem heimisch-reichen Gebiet, akkumulieren Heimische schnell. Starten wir nahe einem Alien-Hotspot, akkumulieren Aliens schnell. Wir m√ºssen von VIELEN Startpunkten starten um das wahre Muster zu sehen.

</div>

### <span class="en">3a: Run from multiple starting points</span><span class="de">3a: Von mehreren Startpunkten starten</span>

```{r}
# Run from 20 different starting points
# Starte von 20 verschiedenen Startpunkten
n_seeds <- 20

# Storage for results (matrix: rows = seeds, columns = plots)
# Speicher f√ºr Ergebnisse (Matrix: Zeilen = Seeds, Spalten = Plots)
native_runs <- matrix(NA, nrow = n_seeds, ncol = sample_size)
alien_runs <- matrix(NA, nrow = n_seeds, ncol = sample_size)

# Run from each starting point
# Starte von jedem Startpunkt
cat("Running", n_seeds, "starting points...\n")
for (seed in 1:n_seeds) {
  nn_order <- nn_walk(sample_header, start_idx = seed)
  native_runs[seed, ] <- build_accumulation(sample_species, nn_order, "____")
  alien_runs[seed, ] <- build_accumulation(sample_species, nn_order, "____")

  if (seed %% 5 == 0) cat("  Completed", seed, "\n")
}
cat("Done!\n")
```

### <span class="en">3b: Calculate mean and confidence intervals</span><span class="de">3b: Berechne Mittelwert und Konfidenzintervalle</span>

```{r}
# Mean across all runs
# Mittelwert √ºber alle L√§ufe
native_mean <- apply(native_runs, 2, ____)
alien_mean <- apply(alien_runs, 2, mean)

# 95% confidence intervals (2.5% and 97.5% quantiles)
# 95% Konfidenzintervalle (2.5% und 97.5% Quantile)
native_lower <- apply(native_runs, 2, function(x) quantile(x, 0.025))
native_upper <- apply(native_runs, 2, function(x) quantile(x, ____))

alien_lower <- apply(alien_runs, 2, function(x) quantile(x, ____))
alien_upper <- apply(alien_runs, 2, function(x) quantile(x, 0.975))

# How much variation is there?
# Wie viel Variation gibt es?
midpoint <- sample_size %/% 2
native_cv <- round(100 * sd(native_runs[, midpoint]) / mean(native_runs[, midpoint]), 1)
alien_cv <- round(100 * sd(alien_runs[, midpoint]) / mean(alien_runs[, midpoint]), 1)

cat("Variation at midpoint:\n")
cat("  Native CV:", native_cv, "%\n")
cat("  Alien CV:", alien_cv, "%\n")
```

### <span class="en">3c: Plot with uncertainty bands</span><span class="de">3c: Plotte mit Unsicherheitsb√§ndern</span>

```{r}
# Create summary data frame
# Erstelle Zusammenfassungs-Data-Frame
summary_data <- data.frame(
  plots = rep(1:sample_size, 2),
  mean = c(native_mean, alien_mean),
  lower = c(native_lower, alien_lower),
  upper = c(native_upper, alien_upper),
  status = rep(c("Native", "Alien"), each = sample_size)
)

# Plot with shaded confidence bands
# Plotte mit schattierten Konfidenzb√§ndern
ggplot(summary_data, aes(x = plots)) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = status), alpha = ____) +
  geom_line(aes(y = mean, color = status), linewidth = 1.2) +
  scale_color_manual(values = c("Native" = "darkgreen", "Alien" = "red")) +
  scale_fill_manual(values = c("Native" = "darkgreen", "Alien" = "red")) +
  labs(
    title = "Species Accumulation with Uncertainty",
    subtitle = paste(n_seeds, "starting points - shaded = 95% CI"),
    x = "Plots Sampled",
    y = "Cumulative Species",
    color = "", fill = ""
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

<div class="hint">
<span class="en">Hint: Use `mean` for the average. For 95% CI, upper bound is 0.975 quantile, lower is 0.025.</span>
<span class="de">Hinweis: Benutze `mean` f√ºr den Durchschnitt. F√ºr 95% CI ist obere Grenze 0.975 Quantil, untere 0.025.</span>
</div>

---

# <span class="en">Exercise 4: Comparing Saturation Speed</span><span class="de">√úbung 4: S√§ttigungsgeschwindigkeit vergleichen</span>

<div class="en">

**Concept:** **Saturation** is when we've found most of the species and the curve flattens. If natives saturate FASTER than aliens, it means natives are more evenly distributed (we find them everywhere). If aliens saturate SLOWER, they're more patchy (clustered in certain areas).

</div>

<div class="de">

**Konzept:** **S√§ttigung** ist wenn wir die meisten Arten gefunden haben und die Kurve abflacht. Wenn Heimische SCHNELLER saturieren, sind sie gleichm√§√üiger verteilt (wir finden sie √ºberall). Wenn Aliens LANGSAMER saturieren, sind sie fleckenhafter (in bestimmten Gebieten geclustert).

</div>

### <span class="en">4a: Find saturation points</span><span class="de">4a: Finde S√§ttigungspunkte</span>

```{r}
# At what point do we reach 80% of species?
# Bei welchem Punkt erreichen wir 80% der Arten?
native_sat <- apply(native_runs, 1, find_saturation, threshold = 0.8)
alien_sat <- apply(alien_runs, 1, find_saturation, threshold = ____)

# Convert to percentage of total plots
# In Prozent der Gesamtplots umwandeln
native_sat_pct <- 100 * native_sat / sample_size
alien_sat_pct <- 100 * alien_sat / sample_size

cat("Plots needed to reach 80% of species:\n")
cat("  Native:", round(mean(native_sat_pct)), "% (SD:", round(sd(native_sat_pct), 1), ")\n")
cat("  Alien:", round(mean(alien_sat_pct)), "% (SD:", round(sd(alien_sat_pct), 1), ")\n")
```

### <span class="en">4b: Visualize with boxplot</span><span class="de">4b: Visualisiere mit Boxplot</span>

```{r}
# Create data for boxplot
# Erstelle Daten f√ºr Boxplot
sat_data <- data.frame(
  saturation_pct = c(native_sat_pct, alien_sat_pct),
  status = rep(c("Native", "Alien"), each = n_seeds)
)

ggplot(sat_data, aes(x = status, y = saturation_pct, fill = status)) +
  geom_boxplot() +
  scale_fill_manual(values = c("Native" = "____", "Alien" = "____")) +
  labs(
    title = "How Fast Do Species Saturate?",
    subtitle = "% of plots needed to find 80% of species",
    y = "% of Plots Needed",
    x = ""
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

### <span class="en">4c: Calculate slope ratio</span><span class="de">4c: Berechne Steigungsverh√§ltnis</span>

```{r}
# Compare early vs late slopes
# Vergleiche fr√ºhe vs sp√§te Steigungen
# High ratio = fast saturation (steep early, flat late)
# Hohes Verh√§ltnis = schnelle S√§ttigung (steil fr√ºh, flach sp√§t)

calc_slope_ratio <- function(curve) {
  n <- length(curve)
  early_end <- round(n * 0.2)
  late_start <- round(n * 0.8)

  early_slope <- (curve[early_end] - curve[1]) / early_end
  late_slope <- (curve[n] - curve[late_start]) / (n - late_start)

  if (late_slope > 0) return(early_slope / late_slope)
  else return(NA)
}

native_ratios <- apply(native_runs, 1, calc_slope_ratio)
alien_ratios <- apply(alien_runs, 1, ____)

cat("Slope ratio (higher = faster saturation):\n")
cat("  Native:", round(mean(native_ratios, na.rm = TRUE), 1), "\n")
cat("  Alien:", round(mean(alien_ratios, na.rm = TRUE), 1), "\n")
```

<div class="hint">
<span class="en">Hint: Fill in colors "darkgreen" and "red". For slope ratio, use `calc_slope_ratio`.</span>
<span class="de">Hinweis: F√ºlle Farben "darkgreen" und "red" ein. F√ºr Steigungsverh√§ltnis nutze `calc_slope_ratio`.</span>
</div>

---

# <span class="en">Exercise 5: Geographic Patterns</span><span class="de">√úbung 5: Geografische Muster</span>

<div class="en">

**Concept:** Does it matter WHERE in Austria we start? Some areas might have more aliens (near cities, roads). Let's map how starting location affects what we find!

</div>

<div class="de">

**Konzept:** Ist es wichtig WO in √ñsterreich wir starten? Manche Gebiete haben vielleicht mehr Aliens (nahe St√§dten, Stra√üen). Kartieren wir wie der Startort beeinflusst was wir finden!

</div>

### <span class="en">5a: Map alien proportion by starting location</span><span class="de">5a: Kartiere Alien-Anteil nach Startort</span>

```{r}
# Test from 30 different starting locations
# Teste von 30 verschiedenen Startorten
n_map_seeds <- 30
checkpoint <- 75  # Check after this many plots

seed_results <- data.frame(
  seed_idx = 1:n_map_seeds,
  seed_lon = numeric(n_map_seeds),
  seed_lat = numeric(n_map_seeds),
  native_count = numeric(n_map_seeds),
  alien_count = numeric(n_map_seeds)
)

for (i in 1:n_map_seeds) {
  # Record starting location
  # Erfasse Startort
  seed_results$seed_lon[i] <- sample_header$Longitude[i]
  seed_results$seed_lat[i] <- sample_header$Latitude[i]

  # Run from this starting point
  # Starte von diesem Startpunkt
  nn_order <- nn_walk(sample_header, start_idx = i)

  # Get counts at checkpoint
  # Hole Z√§hlungen am Checkpoint
  native_curve <- build_accumulation(sample_species, nn_order, "nat")
  alien_curve <- build_accumulation(sample_species, nn_order, "neo")

  seed_results$native_count[i] <- native_curve[min(checkpoint, length(native_curve))]
  seed_results$alien_count[i] <- alien_curve[min(checkpoint, length(alien_curve))]
}

# Calculate alien proportion
# Berechne Alien-Anteil
seed_results$alien_prop <- seed_results$alien_count /
  (seed_results$native_count + seed_results$____)

# Map it!
# Kartiere es!
ggplot(seed_results, aes(x = seed_lon, y = seed_lat, color = alien_prop)) +
  geom_point(size = 4) +
  scale_color_gradient2(
    low = "darkgreen", mid = "yellow", high = "red",
    midpoint = mean(seed_results$alien_prop),
    name = "Alien\nproportion"
  ) +
  coord_quickmap() +
  labs(
    title = "How Starting Location Affects Alien Detection",
    subtitle = paste("Alien proportion after", checkpoint, "plots"),
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal()
```

<div class="hint">
<span class="en">Hint: Fill in `alien_count` to complete the proportion calculation.</span>
<span class="de">Hinweis: F√ºlle `alien_count` ein um die Anteilsberechnung zu vervollst√§ndigen.</span>
</div>

---

# <span class="en">Exercise 6: Final Publication Plot</span><span class="de">√úbung 6: Finaler Publikationsplot</span>

<div class="en">

**Concept:** Let's put it all together and create a publication-quality figure that shows our main finding: how native vs alien species accumulate differently across Austrian plots.

</div>

<div class="de">

**Konzept:** Fassen wir alles zusammen und erstellen eine publikationsreife Abbildung die unser Hauptergebnis zeigt: wie heimische vs Alien-Arten unterschiedlich √ºber √∂sterreichische Plots akkumulieren.

</div>

### <span class="en">6a: Run full analysis</span><span class="de">6a: F√ºhre vollst√§ndige Analyse aus</span>

```{r}
# Larger sample for final analysis
# Gr√∂√üere Stichprobe f√ºr finale Analyse
n_seeds <- 30
sample_size <- 200

set.seed(2024)
sample_ids <- sample(unique(header$PlotObservationID), sample_size)
sample_header <- header %>% filter(PlotObservationID %in% sample_ids)
sample_species <- species %>% filter(PlotObservationID %in% sample_ids)

# Run from all seeds
# Starte von allen Seeds
native_runs <- matrix(NA, nrow = n_seeds, ncol = sample_size)
alien_runs <- matrix(NA, nrow = n_seeds, ncol = sample_size)

cat("Running full analysis...\n")
for (seed in 1:n_seeds) {
  nn_order <- nn_walk(sample_header, start_idx = seed)
  native_runs[seed, ] <- build_accumulation(sample_species, nn_order, "nat")
  alien_runs[seed, ] <- build_accumulation(sample_species, nn_order, "neo")
  if (seed %% 10 == 0) cat("  Completed", seed, "of", n_seeds, "\n")
}
cat("Done!\n")

# Calculate summaries
# Berechne Zusammenfassungen
results <- data.frame(
  plots = rep(1:sample_size, 2),
  mean = c(apply(native_runs, 2, mean), apply(alien_runs, 2, mean)),
  lower = c(apply(native_runs, 2, function(x) quantile(x, 0.025)),
            apply(alien_runs, 2, function(x) quantile(x, 0.025))),
  upper = c(apply(native_runs, 2, function(x) quantile(x, 0.975)),
            apply(alien_runs, 2, function(x) quantile(x, 0.975))),
  status = rep(c("Native", "Alien"), each = sample_size)
)
```

### <span class="en">6b: Create publication-quality figure</span><span class="de">6b: Erstelle publikationsreife Abbildung</span>

```{r}
# Publication-ready figure
# Publikationsreife Abbildung
final_plot <- ggplot(results, aes(x = plots)) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = status), alpha = 0.25) +
  geom_line(aes(y = mean, color = status), linewidth = 1.3) +
  scale_color_manual(values = c("Native" = "#228B22", "Alien" = "#DC143C")) +
  scale_fill_manual(values = c("Native" = "#228B22", "Alien" = "#DC143C")) +
  labs(
    title = "Species Accumulation: Native vs Alien Plants in Austria",
    subtitle = paste0(n_seeds, " starting points, 95% confidence intervals"),
    x = "Number of Plots Sampled",
    y = "Cumulative Species Count",
    color = "", fill = ""
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = c(0.85, 0.2),
    legend.background = element_rect(fill = "white", color = "gray80"),
    plot.title = element_text(face = "bold")
  )

print(final_plot)

# Save it (uncomment to run)
# ggsave("austria_accumulation.png", final_plot, width = 10, height = 7, dpi = 300)
```

---

# <span class="en">Exercise 7: Interpret Your Results</span><span class="de">√úbung 7: Interpretiere deine Ergebnisse</span>

<div class="en">

**Concept:** Science isn't just about making plots - it's about understanding what they mean! Let's summarize our findings.

</div>

<div class="de">

**Konzept:** Wissenschaft bedeutet nicht nur Plots zu erstellen - es geht darum zu verstehen was sie bedeuten! Fassen wir unsere Ergebnisse zusammen.

</div>

### <span class="en">7a: Generate results summary</span><span class="de">7a: Generiere Ergebniszusammenfassung</span>

```{r}
cat("\n========== RESULTS SUMMARY ==========\n\n")

# Total species found
cat("Species found:\n")
cat("  Native:", round(mean(native_runs[, sample_size])), "species\n")
cat("  Alien:", round(mean(alien_runs[, sample_size])), "species\n\n")

# Saturation comparison
native_sat <- apply(native_runs, 1, find_saturation, threshold = 0.8)
alien_sat <- apply(alien_runs, 1, find_saturation, threshold = 0.8)

cat("Plots to reach 80% of species:\n")
cat("  Native:", round(mean(native_sat)), "plots (",
    round(100*mean(native_sat)/sample_size), "%)\n")
cat("  Alien:", round(mean(alien_sat)), "plots (",
    round(100*mean(alien_sat)/sample_size), "%)\n\n")

# Draw conclusion
cat("========== CONCLUSION ==========\n")
if (mean(native_sat) < mean(alien_sat)) {
  cat("Native species saturate FASTER than aliens!\n")
  cat("-> Natives are more evenly distributed\n")
  cat("-> Aliens are more patchy/clustered\n")
} else {
  cat("Aliens saturate FASTER than natives!\n")
  cat("-> Aliens are more widespread than expected\n")
}
```

<blockquote>
<span class="en">**Discussion Questions:**
1. Do natives really saturate faster? What does this mean ecologically?
2. Why might aliens be more "patchy" (clustered in certain areas)?
3. What would you investigate next? (Urban areas? Elevation? Climate?)
</span>
<span class="de">**Diskussionsfragen:**
1. Saturieren Heimische wirklich schneller? Was bedeutet das √∂kologisch?
2. Warum k√∂nnten Aliens "fleckenhafter" sein (in bestimmten Gebieten geclustert)?
3. Was w√ºrdest du als n√§chstes untersuchen? (St√§dtische Gebiete? H√∂henlage? Klima?)
</span>
</blockquote>

---

# <span class="en">Quick Reference</span><span class="de">Schnellreferenz</span>

<div class="en">

| Function | Purpose | Example |
|----------|---------|---------|
| `apply()` | Apply function to matrix | `apply(mat, 2, mean)` |
| `quantile()` | Get percentiles | `quantile(x, 0.975)` |
| `geom_ribbon()` | Add shaded band | `+ geom_ribbon(aes(ymin, ymax))` |
| `scale_color_manual()` | Custom colors | `+ scale_color_manual(values = c(...))` |
| `scale_color_gradient2()` | Diverging color scale | `+ scale_color_gradient2(...)` |
| `ggsave()` | Save plot to file | `ggsave("plot.png", width = 10)` |
| `theme()` | Customize plot appearance | `+ theme(legend.position = "bottom")` |
| `element_rect()` | Rectangle element for themes | `element_rect(fill = "white")` |
| `element_text()` | Text element for themes | `element_text(face = "bold")` |

</div>

<div class="de">

| Funktion | Zweck | Beispiel |
|----------|-------|----------|
| `apply()` | Funktion auf Matrix anwenden | `apply(mat, 2, mean)` |
| `quantile()` | Perzentile berechnen | `quantile(x, 0.975)` |
| `geom_ribbon()` | Schattiertes Band | `+ geom_ribbon(aes(ymin, ymax))` |
| `scale_color_manual()` | Eigene Farben | `+ scale_color_manual(values = c(...))` |
| `scale_color_gradient2()` | Divergierende Farbskala | `+ scale_color_gradient2(...)` |
| `ggsave()` | Plot in Datei speichern | `ggsave("plot.png", width = 10)` |
| `theme()` | Plot-Erscheinung anpassen | `+ theme(legend.position = "bottom")` |
| `element_rect()` | Rechteck-Element f√ºr Themes | `element_rect(fill = "white")` |
| `element_text()` | Text-Element f√ºr Themes | `element_text(face = "bold")` |

</div>
