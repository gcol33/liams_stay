---
title: '<span class="en">Day 2: Exercises</span><span class="de">Tag 2: √úbungen</span>'
subtitle: '<span class="en">Advanced Analysis & Research Project</span><span class="de">Fortgeschrittene Analyse & Forschungsprojekt</span>'
author: '<span class="en">Fill in the blanks!</span><span class="de">F√ºlle die L√ºcken aus!</span>'
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: flatly
    self_contained: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, message = FALSE, warning = FALSE)
```

```{=html}
<style>
/* ========== PLAYFUL WORKSHOP THEME ========== */

body {
 font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
 line-height: 1.7;
 background-color: #fafffe;
}

h1 {
 color: #2E7D32 !important;
 border-bottom: 3px solid #4CAF50;
 padding-bottom: 10px;
}

h2 {
 color: #388E3C !important;
 margin-top: 2em;
}

h3 {
 color: #43A047 !important;
}

h4 {
 color: #66BB6A !important;
 border-left: 4px solid #4CAF50;
 padding-left: 10px;
}

/* Code blocks with copy button support */
pre {
 background-color: #f5f5f5 !important;
 border-left: 4px solid #4CAF50 !important;
 padding: 15px;
 padding-top: 35px;
 border-radius: 8px;
 overflow-x: auto;
 position: relative !important;
}

code {
 background-color: #E8F5E9;
 padding: 2px 6px;
 border-radius: 4px;
 color: #2E7D32;
}

pre code {
 background-color: transparent;
 padding: 0;
}

/* Copy button styling */
.copy-btn {
 position: absolute !important;
 top: 8px !important;
 right: 8px !important;
 padding: 4px 12px;
 font-size: 12px;
 background: #4CAF50;
 color: white;
 border: none;
 border-radius: 4px;
 cursor: pointer;
 opacity: 0;
 transition: opacity 0.2s, background 0.2s;
 z-index: 100;
}

pre:hover .copy-btn {
 opacity: 1;
}

.copy-btn:hover {
 background: #2E7D32;
}

.copy-btn.copied {
 background: #1976D2;
}

blockquote {
 border-left: 4px solid #FF9800;
 background-color: #FFF8E1;
 padding: 15px 20px;
 margin: 1em 0;
 border-radius: 0 8px 8px 0;
}

hr {
 border: none;
 height: 3px;
 background: linear-gradient(to right, #4CAF50, #81C784, #C8E6C9, #81C784, #4CAF50);
 margin: 2em 0;
 border-radius: 2px;
}

.tocify {
 border: none !important;
 border-radius: 12px !important;
 background-color: #f1f8e9 !important;
 box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.tocify-item.active, .tocify-item.active:hover {
 background-color: #4CAF50 !important;
 color: white !important;
}

/* Exercise hint */
.hint {
 background-color: #E3F2FD;
 border: 1px solid #1976D2;
 border-radius: 8px;
 padding: 10px 15px;
 margin: 1em 0;
 font-size: 0.9em;
}

.hint::before {
 content: "üí° ";
}

/* Explore box */
.explore {
 background-color: #FFF3E0;
 border: 1px solid #FF9800;
 border-radius: 8px;
 padding: 10px 15px;
 margin: 1em 0;
 font-size: 0.9em;
}

.explore::before {
 content: "üîç ";
}

/* Debug box */
.debug {
 background-color: #FFEBEE;
 border: 1px solid #F44336;
 border-radius: 8px;
 padding: 10px 15px;
 margin: 1em 0;
 font-size: 0.9em;
}

.debug::before {
 content: "üêõ ";
}

/* Predict box */
.predict {
 background-color: #E8F5E9;
 border: 1px solid #4CAF50;
 border-radius: 8px;
 padding: 10px 15px;
 margin: 1em 0;
 font-size: 0.9em;
}

.predict::before {
 content: "ü§î ";
}

/* ========== LANGUAGE TOGGLE ========== */

.lang-toggle {
 position: fixed;
 top: 10px;
 right: 20px;
 z-index: 9999;
 background: linear-gradient(135deg, #2E7D32, #4CAF50);
 padding: 8px 12px;
 border-radius: 25px;
 box-shadow: 0 4px 15px rgba(46, 125, 50, 0.3);
}

.lang-toggle button {
 background: transparent;
 border: none;
 color: #fff;
 padding: 6px 14px;
 cursor: pointer;
 font-weight: bold;
 border-radius: 20px;
 transition: all 0.3s;
 font-size: 14px;
}

.lang-toggle button.active {
 background: white;
 color: #2E7D32;
}

.lang-toggle button:hover:not(.active) {
 background: rgba(255,255,255,0.2);
}

.de { display: none; }
.en { display: inline; }

body.lang-de .de { display: inline; }
body.lang-de .en { display: none; }

div.de, p.de, li.de, h1.de, h2.de, h3.de, h4.de, section.de { display: none; }
div.en, p.en, li.en, h1.en, h2.en, h3.en, h4.en, section.en { display: block; }

body.lang-de div.de, body.lang-de p.de, body.lang-de li.de,
body.lang-de h1.de, body.lang-de h2.de, body.lang-de h3.de,
body.lang-de h4.de, body.lang-de section.de { display: block; }

body.lang-de div.en, body.lang-de p.en, body.lang-de li.en,
body.lang-de h1.en, body.lang-de h2.en, body.lang-de h3.en,
body.lang-de h4.en, body.lang-de section.en { display: none; }

body.lang-de #TOC .en { display: none; }
body.lang-de #TOC .de { display: inline; }
#TOC .de { display: none; }
#TOC .en { display: inline; }

@media print {
 .tocify, .lang-toggle, .copy-btn { display: none; }
}

/* ========== MOBILE RESPONSIVE ========== */
@media (max-width: 768px) {
  body { font-size: 14px; line-height: 1.5; }
  h1 { font-size: 1.5rem; }
  h2 { font-size: 1.3rem; }
  h3 { font-size: 1.1rem; }
  .lang-toggle { top: 5px; right: 10px; padding: 5px 8px; }
  .lang-toggle button { padding: 4px 10px; font-size: 12px; }
  table { font-size: 12px; display: block; overflow-x: auto; white-space: nowrap; }
  th, td { padding: 6px 8px; }
  blockquote { padding: 10px 15px; margin: 0.5em 0; }
  pre { font-size: 11px; padding: 10px; }
  code { font-size: 11px; }
  img, .figure img { max-width: 100%; height: auto; }
  .code-exercise { padding: 10px; }
}
</style>
```

```{=html}
<script>
$(document).ready(function() {
  // Language toggle
  var toggle = $('<div class="lang-toggle"><button id="btn-en" class="active">EN</button><button id="btn-de">DE</button></div>');
  $('body').append(toggle);

  var savedLang = localStorage.getItem('workshop-lang');
  var browserLang = navigator.language.substring(0, 2);
  var defaultLang = savedLang || (browserLang === 'de' ? 'de' : 'en');

  function setLanguage(lang) {
    $('body').removeClass('lang-en lang-de').addClass('lang-' + lang);
    $('#btn-en').toggleClass('active', lang === 'en');
    $('#btn-de').toggleClass('active', lang === 'de');
    localStorage.setItem('workshop-lang', lang);
  }

  if (defaultLang === 'de') {
    setLanguage('de');
  }

  $('#btn-en').click(function() { setLanguage('en'); });
  $('#btn-de').click(function() { setLanguage('de'); });

  // Copy button for code blocks
  $('pre').each(function() {
    var pre = $(this);
    var btn = $('<button class="copy-btn">Copy</button>');

    btn.click(function() {
      var code = pre.find('code');
      var text = code.length ? code.text() : pre.text();

      function showSuccess() {
        btn.text('Copied!').addClass('copied');
        setTimeout(function() {
          btn.text('Copy').removeClass('copied');
        }, 2000);
      }

      function fallbackCopy() {
        var textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        try {
          document.execCommand('copy');
          showSuccess();
        } catch(e) {
          btn.text('Failed');
        }
        document.body.removeChild(textarea);
      }

      // Use clipboard API if available and in secure context, else fallback
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text).then(showSuccess).catch(fallbackCopy);
      } else {
        fallbackCopy();
      }
    });

    pre.css('position', 'relative').append(btn);
  });
});
</script>
```

---

# <span class="en">Part 2: Advanced Analysis - Welcome to Day 2!</span><span class="de">Teil 2: Fortgeschrittene Analyse - Willkommen zu Tag 2!</span>

<div class="en">

Yesterday you built your first species accumulation curve. Today we'll take it to the next level with real scientific analysis!

**What you'll learn today:**

1. **Spatial sampling** - Walk through plots like a real field ecologist
2. **Measuring uncertainty** - Run from multiple starting points
3. **Comparing natives vs aliens** - Do they accumulate differently?
4. **Polished figures** - Make nice-looking plots

**How to use these exercises:**

- Replace each `____` with the correct code
- Run each chunk to see if it works
- Read the hints if you get stuck
- The exercises build on each other - do them in order!

</div>

<div class="de">

Gestern hast du deine erste Artenakkumulationskurve gebaut. Heute bringen wir es mit echter wissenschaftlicher Analyse auf das n√§chste Level!

**Was du heute lernst:**

1. **R√§umliche Probenahme** - Gehe durch Plots wie ein echter Feld√∂kologe
2. **Unsicherheit messen** - Starte von mehreren Punkten
3. **Heimische vs Aliens vergleichen** - Akkumulieren sie unterschiedlich?
4. **Sch√∂ne Abbildungen** - Erstelle ansprechende Plots

**So verwendest du diese √úbungen:**

- Ersetze jedes `____` mit dem richtigen Code
- F√ºhre jeden Chunk aus um zu sehen ob er funktioniert
- Lies die Hinweise wenn du nicht weiterkommst
- Die √úbungen bauen aufeinander auf - mache sie der Reihe nach!

</div>

---

# <span class="en">Exercise 1: Setup - Load Data and Functions</span><span class="de">√úbung 1: Setup - Daten und Funktionen laden</span>

<div class="en">

**Concept:** Before we start, we need to load our data and define some helper functions. These functions will make our analysis easier.

</div>

<div class="de">

**Konzept:** Bevor wir beginnen, m√ºssen wir unsere Daten laden und einige Hilfsfunktionen definieren. Diese Funktionen machen unsere Analyse einfacher.

</div>

### <span class="en">1a: Load packages and data</span><span class="de">1a: Pakete und Daten laden</span>

```{r}
# Load packages
# Pakete laden
library(tidyverse)

# Load data
# Daten laden
header <- read_csv("../data/austria_header.csv")
species <- read_csv("../data/austria_species.csv")

# Check data loaded correctly
# √úberpr√ºfe dass Daten korrekt geladen sind
print(paste("Plots loaded:", nrow(header)))
print(paste("Species records:", nrow(species)))
print(paste("Unique species:", length(unique(species$WFO_TAXON))))
```

### <span class="en">1b: New R Concepts for Today</span><span class="de">1b: Neue R-Konzepte f√ºr heute</span>

<div class="en">

Before we define our helper functions, let's learn some **new R concepts** that we'll use today. Yesterday you learned variables, vectors, and `unique()`. Today we add:

**Writing your own functions - Fibonacci example:**

The Fibonacci sequence: 1, 1, 2, 3, 5, 8, 13... (each number = sum of previous two)

```r
# VERSION 1: Using a vector (stores ALL numbers)
fibonacci_vector <- function(n) {
  fib <- c(1, 1)                      # Start with first two numbers
  for (i in 3:n) {
    fib[i] <- fib[i-1] + fib[i-2]     # Add: previous + one before that
  }
  return(fib)
}

fibonacci_vector(7)  # Returns: 1 1 2 3 5 8 13

# VERSION 2: Using 2 variables (memory efficient - only tracks last 2)
fibonacci_two_vars <- function(n) {
  prev <- 1                           # The number before current
  curr <- 1                           # Current number
  for (i in 3:n) {
    new <- prev + curr                # Calculate next
    prev <- curr                      # Shift: current becomes previous
    curr <- new                       # Shift: new becomes current
  }
  return(curr)
}

fibonacci_two_vars(7)  # Returns: 13 (the 7th Fibonacci number)
```

**Default values in functions:**
```r
# If user doesn't provide 'n', use 10 as default
fibonacci <- function(n = 10) {
  fib <- c(1, 1)
  for (i in 3:n) fib[i] <- fib[i-1] + fib[i-2]
  return(fib)
}

fibonacci()      # Returns first 10 numbers (uses default)
fibonacci(5)     # Returns first 5 numbers
```

**Useful functions we'll use:**

| Function | What it does | Example |
|----------|--------------|---------|
| `paste()` | Combine text and values | `paste("Found:", 5, "species")` |
| `sample()` | Pick random items | `sample(1:100, 5)` picks 5 random numbers |
| `set.seed()` | Make random reproducible | `set.seed(42)` always gives same "random" |
| `rep()` | Repeat values | `rep(FALSE, 5)` gives `FALSE FALSE FALSE FALSE FALSE` |
| `which.min()` | Position of smallest value | `which.min(c(5,2,8))` returns `2` |
| `setdiff()` | What's in A but not B | `setdiff(c(1,2,3), c(2,3,4))` returns `1` |
| `pull()` | Extract column as vector | `data %>% pull(column)` |
| `is.null()` | Check if NULL | `is.null(NULL)` returns `TRUE` |

**Special values:**

- `NULL` = "nothing" / empty / not specified
- `Inf` = infinity (bigger than any number)

</div>

<div class="de">

Bevor wir unsere Hilfsfunktionen definieren, lernen wir einige **neue R-Konzepte**, die wir heute verwenden. Gestern hast du Variablen, Vektoren und `unique()` gelernt. Heute f√ºgen wir hinzu:

**Eigene Funktionen schreiben - Fibonacci-Beispiel:**

Die Fibonacci-Folge: 1, 1, 2, 3, 5, 8, 13... (jede Zahl = Summe der vorherigen zwei)

```r
# VERSION 1: Mit Vektor (speichert ALLE Zahlen)
fibonacci_vektor <- function(n) {
  fib <- c(1, 1)                      # Starte mit ersten zwei Zahlen
  for (i in 3:n) {
    fib[i] <- fib[i-1] + fib[i-2]     # Addiere: vorherige + davor
  }
  return(fib)
}

fibonacci_vektor(7)  # Gibt zur√ºck: 1 1 2 3 5 8 13

# VERSION 2: Mit 2 Variablen (speichereffizient - nur letzte 2)
fibonacci_zwei_vars <- function(n) {
  vorherige <- 1                      # Die Zahl vor der aktuellen
  aktuelle <- 1                       # Aktuelle Zahl
  for (i in 3:n) {
    neue <- vorherige + aktuelle      # Berechne n√§chste
    vorherige <- aktuelle             # Verschiebe: aktuelle wird vorherige
    aktuelle <- neue                  # Verschiebe: neue wird aktuelle
  }
  return(aktuelle)
}

fibonacci_zwei_vars(7)  # Gibt zur√ºck: 13 (die 7. Fibonacci-Zahl)
```

**Standardwerte in Funktionen:**
```r
# Wenn der User 'n' nicht angibt, benutze 10 als Standard
fibonacci <- function(n = 10) {
  fib <- c(1, 1)
  for (i in 3:n) fib[i] <- fib[i-1] + fib[i-2]
  return(fib)
}

fibonacci()      # Gibt erste 10 Zahlen zur√ºck (benutzt Standard)
fibonacci(5)     # Gibt erste 5 Zahlen zur√ºck
```

**N√ºtzliche Funktionen, die wir verwenden:**

| Funktion | Was sie macht | Beispiel |
|----------|---------------|----------|
| `paste()` | Text und Werte kombinieren | `paste("Gefunden:", 5, "Arten")` |
| `sample()` | Zuf√§llige Elemente w√§hlen | `sample(1:100, 5)` w√§hlt 5 Zufallszahlen |
| `set.seed()` | Zufall reproduzierbar machen | `set.seed(42)` gibt immer gleichen "Zufall" |
| `rep()` | Werte wiederholen | `rep(FALSE, 5)` gibt `FALSE FALSE FALSE FALSE FALSE` |
| `which.min()` | Position des kleinsten Werts | `which.min(c(5,2,8))` gibt `2` |
| `setdiff()` | Was ist in A aber nicht in B | `setdiff(c(1,2,3), c(2,3,4))` gibt `1` |
| `pull()` | Spalte als Vektor extrahieren | `data %>% pull(spalte)` |
| `is.null()` | Pr√ºfen ob NULL | `is.null(NULL)` gibt `TRUE` |

**Spezielle Werte:**

- `NULL` = "nichts" / leer / nicht angegeben
- `Inf` = Unendlich (gr√∂√üer als jede Zahl)

</div>

---

### <span class="en">1c: Define helper functions (just copy & run!)</span><span class="de">1c: Hilfsfunktionen definieren (einfach kopieren & ausf√ºhren!)</span>

<div class="en">

**Just run this code block!** You don't need to understand every line - these are tools we'll use later. Click the details below only if you're curious.

</div>

<div class="de">

**F√ºhre diesen Code-Block einfach aus!** Du musst nicht jede Zeile verstehen - das sind Werkzeuge die wir sp√§ter benutzen. Klicke die Details unten nur wenn du neugierig bist.

</div>

```{=html}
<style>
.build-steps { background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; margin: 1em 0; }
.build-step { padding: 15px; border-bottom: 1px solid #dee2e6; }
.build-step:last-child { border-bottom: none; }
.step-header { font-weight: bold; color: #2E7D32; cursor: pointer; display: flex; align-items: center; }
.step-header::before { content: "‚ñ∂ "; margin-right: 8px; transition: transform 0.2s; }
.step-header.open::before { transform: rotate(90deg); }
.step-num { background: #4CAF50; color: white; padding: 2px 8px; border-radius: 12px; margin-right: 10px; font-size: 0.85em; }
.step-content { display: none; margin-top: 10px; padding: 10px; background: white; border-radius: 4px; }
.step-content.show { display: block; }
.step-problem { background: #fff3cd; padding: 8px 12px; border-radius: 4px; margin: 8px 0; border-left: 3px solid #ffc107; }
.step-solution { background: #d4edda; padding: 8px 12px; border-radius: 4px; margin: 8px 0; border-left: 3px solid #28a745; }
</style>

<script>
function toggleStep(el) {
  el.classList.toggle('open');
  el.nextElementSibling.classList.toggle('show');
}
</script>

<h4>üî® Building the Functions Step-by-Step</h4>
<p class="en">Click each step to see how we build up from simple to complete:</p>
<p class="de">Klicke jeden Schritt um zu sehen wie wir von einfach zu vollst√§ndig aufbauen:</p>

<!-- FUNCTION 1: calc_distance -->
<div class="build-steps">
<div class="build-step">
  <div class="step-header" onclick="toggleStep(this)">
    <span class="step-num">1</span>
    <span class="en">calc_distance: Start with the math formula</span>
    <span class="de">calc_distance: Starte mit der Mathe-Formel</span>
  </div>
  <div class="step-content">
    <p class="en"><strong>Goal:</strong> Calculate distance between two points.</p>
    <p class="de"><strong>Ziel:</strong> Berechne Distanz zwischen zwei Punkten.</p>

    <p class="en">Remember Pythagoras? For two points (x1,y1) and (x2,y2):</p>
    <p class="de">Erinnerst du dich an Pythagoras? F√ºr zwei Punkte (x1,y1) und (x2,y2):</p>
    <pre><code>distance = sqrt((x2-x1)¬≤ + (y2-y1)¬≤)</code></pre>

    <p class="en">In R, we just wrap this in a function:</p>
    <p class="de">In R wickeln wir das einfach in eine Funktion:</p>
    <pre><code>calc_distance <- function(x1, y1, x2, y2) {
  sqrt((x2 - x1)^2 + (y2 - y1)^2)
}</code></pre>

    <div class="step-solution">
      <span class="en">‚ú® <strong>Bonus:</strong> This automatically works with vectors! If x2,y2 are vectors of 100 points, you get 100 distances back!</span>
      <span class="de">‚ú® <strong>Bonus:</strong> Das funktioniert automatisch mit Vektoren! Wenn x2,y2 Vektoren mit 100 Punkten sind, bekommst du 100 Distanzen zur√ºck!</span>
    </div>
  </div>
</div>

<!-- FUNCTION 2: nn_walk -->
<div class="build-step">
  <div class="step-header" onclick="toggleStep(this)">
    <span class="step-num">2</span>
    <span class="en">nn_walk: First, think about what we need to track</span>
    <span class="de">nn_walk: Zuerst √ºberlegen was wir verfolgen m√ºssen</span>
  </div>
  <div class="step-content">
    <p class="en"><strong>Goal:</strong> Visit all plots, always going to the nearest unvisited one.</p>
    <p class="de"><strong>Ziel:</strong> Besuche alle Plots, gehe immer zum n√§chsten unbesuchten.</p>

    <p class="en">What do we need to keep track of?</p>
    <p class="de">Was m√ºssen wir verfolgen?</p>
    <ul>
      <li class="en">Which plots have we already visited? ‚Üí <code>visited</code> (TRUE/FALSE for each)</li>
      <li class="de">Welche Plots haben wir schon besucht? ‚Üí <code>visited</code> (TRUE/FALSE f√ºr jeden)</li>
      <li class="en">What order did we visit them? ‚Üí <code>visit_order</code> (list of plot IDs)</li>
      <li class="de">In welcher Reihenfolge haben wir sie besucht? ‚Üí <code>visit_order</code> (Liste der Plot-IDs)</li>
      <li class="en">Where are we now? ‚Üí <code>current</code> (index of current plot)</li>
      <li class="de">Wo sind wir jetzt? ‚Üí <code>current</code> (Index des aktuellen Plots)</li>
    </ul>

    <pre><code># Setup our tracking variables
n <- nrow(header_data)           # total number of plots
visited <- rep(FALSE, n)         # all start as unvisited
visit_order <- numeric(n)        # empty vector to fill
current <- 1                     # start at plot 1</code></pre>
  </div>
</div>

<div class="build-step">
  <div class="step-header" onclick="toggleStep(this)">
    <span class="step-num">3</span>
    <span class="en">nn_walk: Build the main loop</span>
    <span class="de">nn_walk: Baue die Hauptschleife</span>
  </div>
  <div class="step-content">
    <p class="en">Now we loop through, visiting one plot at a time:</p>
    <p class="de">Jetzt schleifen wir durch und besuchen einen Plot nach dem anderen:</p>

    <pre><code>for (i in 1:n) {
  # 1. Mark current plot as visited
  visited[current] <- TRUE

  # 2. Record which plot we visited
  visit_order[i] <- header_data$PlotObservationID[current]

  # 3. Find the next plot (closest unvisited)
  # ... but how?
}</code></pre>

    <div class="step-problem">
      <span class="en">ü§î <strong>Problem:</strong> How do we find the closest UNVISITED plot?</span>
      <span class="de">ü§î <strong>Problem:</strong> Wie finden wir den n√§chsten UNBESUCHTEN Plot?</span>
    </div>
  </div>
</div>

<div class="build-step">
  <div class="step-header" onclick="toggleStep(this)">
    <span class="step-num">4</span>
    <span class="en">nn_walk: The "Infinity Trick" for excluding visited plots</span>
    <span class="de">nn_walk: Der "Unendlich-Trick" zum Ausschlie√üen besuchter Plots</span>
  </div>
  <div class="step-content">
    <p class="en">We calculate distance to ALL plots, then use a clever trick:</p>
    <p class="de">Wir berechnen die Distanz zu ALLEN Plots, dann nutzen wir einen cleveren Trick:</p>

    <pre><code># Calculate distance from current to ALL plots
distances <- calc_distance(
  header_data$Longitude[current], header_data$Latitude[current],
  header_data$Longitude, header_data$Latitude
)

# THE TRICK: Set visited plots to Infinity!
distances[visited] <- Inf

# Now which.min() will never pick a visited plot
current <- which.min(distances)</code></pre>

    <div class="step-solution">
      <span class="en">‚ú® <strong>Why Inf?</strong> Because <code>which.min()</code> finds the smallest value. Infinity can never be smallest, so visited plots are automatically excluded!</span>
      <span class="de">‚ú® <strong>Warum Inf?</strong> Weil <code>which.min()</code> den kleinsten Wert findet. Unendlich kann nie der kleinste sein, also werden besuchte Plots automatisch ausgeschlossen!</span>
    </div>
  </div>
</div>

<div class="build-step">
  <div class="step-header" onclick="toggleStep(this)">
    <span class="step-num">5</span>
    <span class="en">nn_walk: Add flexibility with optional start point</span>
    <span class="de">nn_walk: Flexibilit√§t mit optionalem Startpunkt</span>
  </div>
  <div class="step-content">
    <p class="en">Sometimes we want to control where to start, sometimes random is fine:</p>
    <p class="de">Manchmal wollen wir kontrollieren wo wir starten, manchmal ist zuf√§llig ok:</p>

    <pre><code>nn_walk <- function(header_data, start_idx = NULL) {
  # If user didn't specify, pick random
  if (is.null(start_idx)) {
    start_idx <- sample(1:nrow(header_data), 1)
  }
  current <- start_idx
  # ... rest of function
}</code></pre>

    <div class="step-solution">
      <span class="en">‚ú® <strong>Default = NULL</strong> means "not specified". We check with <code>is.null()</code> and provide our own default behavior.</span>
      <span class="de">‚ú® <strong>Standard = NULL</strong> bedeutet "nicht angegeben". Wir pr√ºfen mit <code>is.null()</code> und liefern unser eigenes Standardverhalten.</span>
    </div>
  </div>
</div>

<!-- FUNCTION 3: build_accumulation -->
<div class="build-step">
  <div class="step-header" onclick="toggleStep(this)">
    <span class="step-num">6</span>
    <span class="en">build_accumulation: Think about what "accumulation" means</span>
    <span class="de">build_accumulation: √úberlege was "Akkumulation" bedeutet</span>
  </div>
  <div class="step-content">
    <p class="en"><strong>Goal:</strong> Count how many UNIQUE species we've found after each plot.</p>
    <p class="de"><strong>Ziel:</strong> Z√§hle wie viele EINZIGARTIGE Arten wir nach jedem Plot gefunden haben.</p>

    <p class="en">Let's think through an example:</p>
    <p class="de">Denken wir ein Beispiel durch:</p>
    <pre><code># Plot 1: Oak, Beech         ‚Üí found = {Oak, Beech}           ‚Üí count = 2
# Plot 2: Beech, Pine        ‚Üí found = {Oak, Beech, Pine}     ‚Üí count = 3
# Plot 3: Oak, Oak, Maple    ‚Üí found = {Oak, Beech, Pine, Maple} ‚Üí count = 4</code></pre>

    <p class="en">Key insight: We only count NEW species (ones we haven't seen before)!</p>
    <p class="de">Schl√ºsselerkenntnis: Wir z√§hlen nur NEUE Arten (die wir noch nicht gesehen haben)!</p>
  </div>
</div>

<div class="build-step">
  <div class="step-header" onclick="toggleStep(this)">
    <span class="step-num">7</span>
    <span class="en">build_accumulation: Use setdiff() to find new species</span>
    <span class="de">build_accumulation: Nutze setdiff() um neue Arten zu finden</span>
  </div>
  <div class="step-content">
    <p class="en"><code>setdiff(A, B)</code> = "what's in A but NOT in B"</p>
    <p class="de"><code>setdiff(A, B)</code> = "was ist in A aber NICHT in B"</p>

    <pre><code>found <- c("Oak", "Beech")           # species we already have
plot_species <- c("Beech", "Pine")   # species in new plot

setdiff(plot_species, found)         # Returns: "Pine"
# Only Pine is NEW!</code></pre>

    <p class="en">This becomes our loop:</p>
    <p class="de">Das wird unsere Schleife:</p>
    <pre><code>found <- c()  # start empty

for (i in 1:length(plot_order)) {
  # Get species in this plot
  plot_spp <- get_species_for_plot(plot_order[i])

  # Find what's NEW
  new_spp <- setdiff(plot_spp, found)

  # Add new species to our collection
  found <- c(found, new_spp)

  # Record the count
  accum[i] <- length(found)
}</code></pre>
  </div>
</div>

<div class="build-step">
  <div class="step-header" onclick="toggleStep(this)">
    <span class="step-num">8</span>
    <span class="en">build_accumulation: Add optional filtering</span>
    <span class="de">build_accumulation: F√ºge optionale Filterung hinzu</span>
  </div>
  <div class="step-content">
    <p class="en">We want ONE function that works for native, alien, or all species:</p>
    <p class="de">Wir wollen EINE Funktion die f√ºr heimische, Alien, oder alle Arten funktioniert:</p>

    <pre><code>build_accumulation <- function(species_data, plot_order, status_filter = NULL) {
  # If filter provided, apply it FIRST
  if (!is.null(status_filter)) {
    species_data <- species_data %>% filter(STATUS == status_filter)
  }
  # ... rest of function works on filtered data
}</code></pre>

    <p class="en">Now we can call it three ways:</p>
    <p class="de">Jetzt k√∂nnen wir sie auf drei Arten aufrufen:</p>
    <pre><code>build_accumulation(species, order)           # all species
build_accumulation(species, order, "nat")    # only native
build_accumulation(species, order, "neo")    # only alien</code></pre>
  </div>
</div>

<!-- FUNCTION 4: find_saturation -->
<div class="build-step">
  <div class="step-header" onclick="toggleStep(this)">
    <span class="step-num">9</span>
    <span class="en">find_saturation: A simple but useful helper</span>
    <span class="de">find_saturation: Ein einfacher aber n√ºtzlicher Helfer</span>
  </div>
  <div class="step-content">
    <p class="en"><strong>Goal:</strong> Find when we've discovered 80% of all species.</p>
    <p class="de"><strong>Ziel:</strong> Finde wann wir 80% aller Arten entdeckt haben.</p>

    <pre><code># If final count is 100 species, target is 80
target <- max(curve) * 0.8

# Find FIRST position where we reach target
# curve >= target gives: FALSE FALSE FALSE TRUE TRUE TRUE ...
# which() gives positions of TRUEs: 4, 5, 6, ...
# [1] gives first one: 4
which(curve >= target)[1]</code></pre>

    <div class="step-solution">
      <span class="en">‚ú® <strong>Pattern:</strong> <code>which(condition)[1]</code> = "first position where condition is TRUE"</span>
      <span class="de">‚ú® <strong>Muster:</strong> <code>which(bedingung)[1]</code> = "erste Position wo Bedingung TRUE ist"</span>
    </div>
  </div>
</div>
</div>

<p class="en">üëÜ <em>Click each step above to expand! Now here are the complete functions:</em></p>
<p class="de">üëÜ <em>Klicke jeden Schritt oben zum Aufklappen! Hier sind die vollst√§ndigen Funktionen:</em></p>
```

```{r}
# ==== FUNCTION 1: calc_distance ====
# Calculates Euclidean distance. VECTORIZED: x2,y2 can be vectors!
# Berechnet Euklidische Distanz. VEKTORISIERT: x2,y2 k√∂nnen Vektoren sein!

calc_distance <- function(x1, y1, x2, y2) {
  # Pythagorean theorem: sqrt(dx¬≤ + dy¬≤). Works with vectors!
  # Satz des Pythagoras: sqrt(dx¬≤ + dy¬≤). Funktioniert mit Vektoren!
  sqrt((x2 - x1)^2 + (y2 - y1)^2)
}


# ==== FUNCTION 2: nn_walk ====
# Nearest-neighbour walk: always go to closest unvisited plot
# Nearest-Neighbour-Walk: gehe immer zum n√§chsten unbesuchten Plot

nn_walk <- function(header_data, start_idx = NULL) {
  # How many plots total? / Wie viele Plots insgesamt?
  n <- nrow(header_data)

  # If no start given, pick random / Wenn kein Start, w√§hle zuf√§llig
  if (is.null(start_idx)) start_idx <- sample(1:n, 1)

  # Track which plots we've visited / Verfolge welche Plots besucht
  visited <- rep(FALSE, n)
  # Store the order we visit them / Speichere Reihenfolge
  visit_order <- numeric(n)
  # Start at this plot / Starte bei diesem Plot
  current <- start_idx

  # Loop through all plots / Schleife durch alle Plots
  for (i in 1:n) {
    # Mark current as visited / Markiere aktuellen als besucht
    visited[current] <- TRUE
    # Save the plot ID / Speichere Plot-ID
    visit_order[i] <- header_data$PlotObservationID[current]

    # If not done yet / Falls noch nicht fertig
    if (i < n) {
      # Calculate distance from current to ALL others (vectorized!)
      # Berechne Distanz von aktuellem zu ALLEN anderen (vektorisiert!)
      distances <- calc_distance(
        header_data$Longitude[current],
        header_data$Latitude[current],
        header_data$Longitude,
        header_data$Latitude
      )
      # Inf trick: visited plots can never be "minimum"
      # Inf-Trick: besuchte Plots k√∂nnen nie "Minimum" sein
      distances[visited] <- Inf
      # Go to closest unvisited / Gehe zum n√§chsten unbesuchten
      current <- which.min(distances)
    }
  }
  # Return the order of plot IDs / Gib Reihenfolge der Plot-IDs zur√ºck
  return(visit_order)
}


# ==== FUNCTION 3: build_accumulation ====
# Count cumulative species as we visit each plot in order
# Z√§hle kumulative Arten w√§hrend wir jeden Plot der Reihe nach besuchen

build_accumulation <- function(species_data, plot_order, status_filter = NULL) {
  # If filter provided (e.g., "nat"), keep only matching species
  # Falls Filter angegeben, behalte nur passende Arten
  if (!is.null(status_filter)) {
    species_data <- species_data %>% filter(STATUS == status_filter)
  }

  # Empty vector to collect all species found / Leerer Vektor f√ºr gefundene Arten
  found <- c()
  # Pre-allocate result vector / Ergebnisvektor vorbelegen
  accum <- numeric(length(plot_order))

  # For each plot in our walking order / F√ºr jeden Plot in unserer Laufreihenfolge
  for (i in seq_along(plot_order)) {
    # Get unique species in this plot / Hole einzigartige Arten in diesem Plot
    plot_spp <- species_data %>%
      # Filter to current plot / Filtere auf aktuellen Plot
      filter(PlotObservationID == plot_order[i]) %>%
      # Extract species names / Extrahiere Artnamen
      pull(WFO_TAXON) %>%
      # Remove duplicates within plot / Entferne Duplikate im Plot
      unique()

    # setdiff: what's NEW? (in plot but not yet found)
    # setdiff: was ist NEU? (im Plot aber noch nicht gefunden)
    new_spp <- setdiff(plot_spp, found)
    # Add new species to our collection / F√ºge neue Arten zur Sammlung
    found <- c(found, new_spp)
    # Count total species so far / Z√§hle Gesamtarten bisher
    accum[i] <- length(found)
  }
  # Return the accumulation curve / Gib Akkumulationskurve zur√ºck
  return(accum)
}


# ==== FUNCTION 4: find_saturation ====
# Find when we reach X% of total species (default 80%)
# Finde wann wir X% der Gesamtarten erreichen (Standard 80%)

find_saturation <- function(curve, threshold = 0.8) {
  # Calculate target: 80% of final count / Berechne Ziel: 80% der Endzahl
  target <- max(curve) * threshold
  # which()[1] = first position where TRUE / Erste Position wo TRUE
  which(curve >= target)[1]
}

print("All functions loaded!")
```

<div class="hint">
<span class="en">Hint: Run both code blocks above. If you get errors, check that the data files exist in `../data/`.</span>
<span class="de">Hinweis: F√ºhre beide Code-Bl√∂cke aus. Bei Fehlern pr√ºfe ob die Dateien in `../data/` existieren.</span>
</div>

```{=html}
<!-- Hidden Rcpp section - only visible when toggled -->
<style>
.rcpp-section {
  display: none;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #e94560;
  border-radius: 12px;
  padding: 20px;
  margin: 1.5em 0;
  color: #eee;
}
.rcpp-section.visible { display: block; }
.rcpp-section h4 { color: #e94560 !important; border: none; margin-top: 0; }
.rcpp-section code { background-color: #0f3460; color: #00ff88; }
.rcpp-section pre { background-color: #0f3460 !important; border-left-color: #e94560 !important; }
.rcpp-section pre code { color: #00ff88; }
.rcpp-toggle {
  background: linear-gradient(135deg, #e94560, #c23a5a);
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  font-weight: bold;
  font-size: 12px;
  margin: 0.5em 0;
}
.rcpp-toggle:hover { background: linear-gradient(135deg, #c23a5a, #a02040); }
</style>

<button class="rcpp-toggle" onclick="document.getElementById('rcpp-turbo').classList.toggle('visible')">
  ‚ö° Turbo Mode: Show/Hide Rcpp Functions
</button>

<div id="rcpp-turbo" class="rcpp-section">
<h4>‚ö° Rcpp Turbo Functions (if R is too slow)</h4>

<p><span class="en">If analyses take too long, these C++ versions are 10-50x faster. Run this ONCE at the start to replace the R functions:</span><span class="de">Falls Analysen zu lange dauern, sind diese C++ Versionen 10-50x schneller. F√ºhre dies EINMAL am Anfang aus um die R-Funktionen zu ersetzen:</span></p>

<pre><code class="r"># Install Rcpp if needed / Installiere Rcpp falls n√∂tig
# install.packages("Rcpp")
library(Rcpp)

# Compile the C++ functions / Kompiliere die C++ Funktionen
cppFunction('
NumericVector nn_walk_cpp(NumericVector lon, NumericVector lat, IntegerVector plot_ids, int start_idx) {
  int n = lon.size();
  NumericVector visit_order(n);
  LogicalVector visited(n, false);

  int current = start_idx - 1;  // Convert to 0-indexed

  for (int i = 0; i &lt; n; i++) {
    visited[current] = true;
    visit_order[i] = plot_ids[current];

    if (i &lt; n - 1) {
      double min_dist = R_PosInf;
      int next_idx = -1;

      for (int j = 0; j &lt; n; j++) {
        if (!visited[j]) {
          double dx = lon[j] - lon[current];
          double dy = lat[j] - lat[current];
          double dist = sqrt(dx*dx + dy*dy);
          if (dist &lt; min_dist) {
            min_dist = dist;
            next_idx = j;
          }
        }
      }
      current = next_idx;
    }
  }
  return visit_order;
}
')

cppFunction('
IntegerVector build_accum_cpp(IntegerVector plot_obs_id, IntegerVector taxon_id,
                               IntegerVector plot_order) {
  int n_plots = plot_order.size();
  IntegerVector accum(n_plots);
  std::set&lt;int&gt; found_species;

  for (int i = 0; i &lt; n_plots; i++) {
    int target_plot = plot_order[i];

    for (int j = 0; j &lt; plot_obs_id.size(); j++) {
      if (plot_obs_id[j] == target_plot) {
        found_species.insert(taxon_id[j]);
      }
    }
    accum[i] = found_species.size();
  }
  return accum;
}
', includes = "#include &lt;set&gt;")

# Wrapper function for nn_walk (drop-in replacement)
# Wrapper-Funktion f√ºr nn_walk (direkter Ersatz)
nn_walk_fast &lt;- function(header_data, start_idx = NULL) {
  if (is.null(start_idx)) start_idx &lt;- sample(1:nrow(header_data), 1)
  nn_walk_cpp(header_data$Longitude, header_data$Latitude,
              header_data$PlotObservationID, start_idx)
}

# Wrapper for build_accumulation (requires pre-processing)
# Wrapper f√ºr build_accumulation (ben√∂tigt Vorverarbeitung)
build_accumulation_fast &lt;- function(species_data, plot_order, status_filter = NULL) {
  if (!is.null(status_filter)) {
    species_data &lt;- species_data[species_data$STATUS == status_filter, ]
  }
  # Convert taxon names to integers for speed
  taxon_factor &lt;- as.integer(factor(species_data$WFO_TAXON))
  build_accum_cpp(species_data$PlotObservationID, taxon_factor, as.integer(plot_order))
}

# Replace the R functions / Ersetze die R-Funktionen
nn_walk &lt;- nn_walk_fast
build_accumulation &lt;- build_accumulation_fast

print("‚ö° Rcpp turbo mode activated! Functions are now 10-50x faster.")
print("‚ö° Rcpp Turbo-Modus aktiviert! Funktionen sind jetzt 10-50x schneller.")
</code></pre>

<p style="font-size: 0.85em; color: #aaa;"><span class="en">Note: Requires Rcpp package and a C++ compiler (Rtools on Windows).</span><span class="de">Hinweis: Ben√∂tigt Rcpp-Paket und einen C++ Compiler (Rtools unter Windows).</span></p>
</div>
```

---

### <span class="en">1d: How fast is my code? (Complexity)</span><span class="de">1d: Wie schnell ist mein Code? (Komplexit√§t)</span>

<div class="en">

**Why does speed matter?** With 100 plots, slow code takes seconds. With 10,000 plots, it could take hours!

**What counts as "work"?** To keep things simple, we count **multiplications** (and divisions). These are the "expensive" operations - additions and assignments are so fast we ignore them.

**The problem - Nested loops:** If you put a loop INSIDE a loop, multiplications multiply!

| N (input size) | Multiplications (N√óN) | Time |
|----------------|----------------------|------|
| 10 | 100 | instant |
| 100 | 10,000 | instant |
| 1,000 | 1,000,000 | slow |
| 10,000 | 100,000,000 | very slow! |

```r
# O(N¬≤) - gets slow fast!
for (i in 1:N) {
  for (j in 1:N) {
    # This runs N √ó N = N¬≤ times!
  }
}
# N=100 ‚Üí 10,000 multiplications
# N=1000 ‚Üí 1,000,000 multiplications (1000√ó slower!)
```

Our `nn_walk` function has this O(N¬≤) behavior (it checks distance to all plots at each step). This is exactly when it makes sense to use a **compiled language** (like C++) instead of an **interpreted language** (like R). Compiled languages run the same operations 10-100√ó faster - that's why we offer the Rcpp version!

</div>

<div class="de">

**Warum ist Geschwindigkeit wichtig?** Mit 100 Plots dauert langsamer Code Sekunden. Mit 10.000 Plots k√∂nnte es Stunden dauern!

**Was z√§hlt als "Arbeit"?** Um es einfach zu halten, z√§hlen wir **Multiplikationen** (und Divisionen). Das sind die "teuren" Operationen - Additionen und Zuweisungen sind so schnell, dass wir sie ignorieren.

**Das Problem - Verschachtelte Schleifen:** Wenn du eine Schleife IN eine Schleife packst, multiplizieren sich die Multiplikationen!

| N (Eingabegr√∂√üe) | Multiplikationen (N√óN) | Zeit |
|------------------|----------------------|------|
| 10 | 100 | sofort |
| 100 | 10.000 | sofort |
| 1.000 | 1.000.000 | langsam |
| 10.000 | 100.000.000 | sehr langsam! |

```r
# O(N¬≤) - wird schnell langsam!
for (i in 1:N) {
  for (j in 1:N) {
    # Das l√§uft N √ó N = N¬≤ mal!
  }
}
# N=100 ‚Üí 10.000 Multiplikationen
# N=1000 ‚Üí 1.000.000 Multiplikationen (1000√ó langsamer!)
```

Unsere `nn_walk` Funktion hat dieses O(N¬≤) Verhalten (sie pr√ºft die Distanz zu allen Plots bei jedem Schritt). Genau dann macht es Sinn, eine **kompilierte Sprache** (wie C++) statt einer **interpretierten Sprache** (wie R) zu verwenden. Kompilierte Sprachen f√ºhren die gleichen Operationen 10-100√ó schneller aus - deshalb bieten wir die Rcpp-Version an!

</div>

---

# <span class="en">Exercise 2: Understanding Spatial Sampling</span><span class="de">√úbung 2: R√§umliche Probenahme verstehen</span>

<div class="en">

**Concept:** When we sample plots randomly, we might jump all over the map. But a **nearest-neighbour walk** samples like a real ecologist would - always going to the closest unvisited plot. This creates a realistic spatial accumulation curve.

**New concepts used here:**

| Concept | What it does | Example |
|---------|--------------|---------|
| `%in%` | Check if values are in a list | `filter(ID %in% my_ids)` |
| `scale_color_manual()` | Set custom colors for categories | `values = c("A" = "red", "B" = "blue")` |

</div>

<div class="de">

**Konzept:** Wenn wir Plots zuf√§llig sampeln, springen wir vielleicht √ºber die ganze Karte. Aber ein **Nearest-Neighbour-Walk** sampelt wie ein echter √ñkologe - geht immer zum n√§chsten unbesuchten Plot. Das erstellt eine realistische r√§umliche Akkumulationskurve.

**Neue Konzepte hier:**

| Konzept | Was es macht | Beispiel |
|---------|--------------|----------|
| `%in%` | Pr√ºft ob Werte in einer Liste sind | `filter(ID %in% meine_ids)` |
| `scale_color_manual()` | Setzt eigene Farben f√ºr Kategorien | `values = c("A" = "red", "B" = "blue")` |

</div>

### <span class="en">2a: Create a sample dataset</span><span class="de">2a: Erstelle einen Beispieldatensatz</span>

```{r}
# Take a random sample of 150 plots (for speed)
# Nimm eine zuf√§llige Stichprobe von 150 Plots (f√ºr Geschwindigkeit)
set.seed(42)  # For reproducibility / F√ºr Reproduzierbarkeit
sample_size <- 150

sample_ids <- sample(unique(header$PlotObservationID), sample_size)
sample_header <- header %>% filter(PlotObservationID %in% sample_ids)
sample_species <- species %>% filter(PlotObservationID %in% sample_ids)

print(paste("Sample created:", nrow(sample_header), "plots"))
```

### <span class="en">2b: Run a nearest-neighbour walk</span><span class="de">2b: F√ºhre einen Nearest-Neighbour-Walk aus</span>

```{r}
# Start from plot 1 and walk to nearest neighbours
# Starte von Plot 1 und gehe zu n√§chsten Nachbarn
nn_order <- nn_walk(sample_header, start_idx = 1)

# Build curves for native and alien species
# Baue Kurven f√ºr heimische und Alien-Arten
native_curve <- build_accumulation(sample_species, nn_order, "____")
alien_curve <- build_accumulation(sample_species, nn_order, "____")

# Check the results
# √úberpr√ºfe die Ergebnisse
print(paste("Native species found:", max(native_curve)))
print(paste("Alien species found:", max(alien_curve)))
```

### <span class="en">2c: Plot the comparison</span><span class="de">2c: Plotte den Vergleich</span>

```{r}
# Create data frame for plotting
# Erstelle Data Frame zum Plotten
curve_data <- data.frame(
  plots = rep(1:sample_size, 2),
  species = c(native_curve, alien_curve),
  status = rep(c("Native", "Alien"), each = sample_size)
)

ggplot(curve_data, aes(x = plots, y = species, color = status)) +
  geom_line(linewidth = 1.2) +
  scale_color_manual(values = c("Native" = "darkgreen", "Alien" = "____")) +
  labs(
    title = "Native vs Alien Species Accumulation",
    x = "Plots Sampled (Nearest-Neighbour Order)",
    y = "Cumulative Species",
    color = ""
  ) +
  theme_minimal()
```

<div class="hint">
<span class="en">Hint: Native species use STATUS = "nat", alien species use STATUS = "neo".</span>
<span class="de">Hinweis: Heimische Arten haben STATUS = "nat", Alien-Arten haben STATUS = "neo".</span>
</div>

---

# <span class="en">Exercise 3: Measuring Uncertainty</span><span class="de">√úbung 3: Unsicherheit messen</span>

<div class="en">

**Concept:** The curve we get depends on WHERE we start! If we start in a native-rich area, natives accumulate fast. If we start near an alien hotspot, aliens accumulate fast. We need to run from MANY starting points to see the true pattern.

**New concepts in this exercise:**

| Concept | What it does | Example |
|---------|--------------|---------|
| `matrix(NA, nrow, ncol)` | Create empty table with rows & columns | `matrix(NA, nrow=20, ncol=100)` |
| `colMeans(mat)` | Mean of each column | `colMeans(mat)` returns one mean per column |
| `sd()` | Standard deviation (spread of values) | `sd(c(1,2,3,4,5))` returns 1.58 |
| `quantile(x, p)` | Value at percentile p | `quantile(x, 0.975)` = 97.5th percentile |
| `geom_ribbon()` | Shaded band in ggplot | `geom_ribbon(aes(ymin, ymax))` |
| `alpha = 0.3` | Transparency (0=invisible, 1=solid) | Makes bands see-through |

**Why matrix() instead of data.frame()?**
- `matrix` = ALL values are the same type (only numbers). Faster for math!
- `data.frame` = columns can be different types (text, numbers, TRUE/FALSE)

We use matrix here because we only store numbers and need to do fast calculations.

</div>

<div class="de">

**Konzept:** Die Kurve die wir bekommen h√§ngt davon ab WO wir starten! Starten wir in einem heimisch-reichen Gebiet, akkumulieren Heimische schnell. Starten wir nahe einem Alien-Hotspot, akkumulieren Aliens schnell. Wir m√ºssen von VIELEN Startpunkten starten um das wahre Muster zu sehen.

**Neue Konzepte in dieser √úbung:**

| Konzept | Was es macht | Beispiel |
|---------|--------------|----------|
| `matrix(NA, nrow, ncol)` | Erstelle leere Tabelle mit Zeilen & Spalten | `matrix(NA, nrow=20, ncol=100)` |
| `colMeans(mat)` | Mittelwert jeder Spalte | `colMeans(mat)` gibt einen Mittelwert pro Spalte |
| `sd()` | Standardabweichung (Streuung der Werte) | `sd(c(1,2,3,4,5))` gibt 1.58 |
| `quantile(x, p)` | Wert am Perzentil p | `quantile(x, 0.975)` = 97.5-tes Perzentil |
| `geom_ribbon()` | Schattiertes Band in ggplot | `geom_ribbon(aes(ymin, ymax))` |
| `alpha = 0.3` | Transparenz (0=unsichtbar, 1=solide) | Macht B√§nder durchsichtig |

**Warum matrix() statt data.frame()?**
- `matrix` = ALLE Werte sind gleicher Typ (nur Zahlen). Schneller f√ºr Mathe!
- `data.frame` = Spalten k√∂nnen verschiedene Typen sein (Text, Zahlen, TRUE/FALSE)

Wir benutzen matrix hier weil wir nur Zahlen speichern und schnelle Berechnungen brauchen.

</div>

### <span class="en">3a: Run from multiple starting points</span><span class="de">3a: Von mehreren Startpunkten starten</span>

```{r}
# Run from 20 different starting points
# Starte von 20 verschiedenen Startpunkten
n_seeds <- 20

# Storage for results (matrix: rows = seeds, columns = plots)
# Speicher f√ºr Ergebnisse (Matrix: Zeilen = Seeds, Spalten = Plots)
native_runs <- matrix(NA, nrow = n_seeds, ncol = sample_size)
alien_runs <- matrix(NA, nrow = n_seeds, ncol = sample_size)

# Run from each starting point
# Starte von jedem Startpunkt
print(paste("Running", n_seeds, "starting points..."))
for (seed in 1:n_seeds) {
  nn_order <- nn_walk(sample_header, start_idx = seed)
  native_runs[seed, ] <- build_accumulation(sample_species, nn_order, "____")
  alien_runs[seed, ] <- build_accumulation(sample_species, nn_order, "____")

  if (seed %% 5 == 0) print(paste("  Completed", seed))
}
print("Done!")
```

### <span class="en">3b: Calculate mean and confidence intervals</span><span class="de">3b: Berechne Mittelwert und Konfidenzintervalle</span>

```{r}
# Mean across all runs (colMeans = mean of each column)
# Mittelwert √ºber alle L√§ufe (colMeans = Mittelwert jeder Spalte)
native_mean <- colMeans(____)
alien_mean <- colMeans(alien_runs)

# 95% confidence intervals using a loop
# 95% Konfidenzintervalle mit einer Schleife
native_lower <- numeric(sample_size)
native_upper <- numeric(sample_size)
alien_lower <- numeric(sample_size)
alien_upper <- numeric(sample_size)

for (i in 1:sample_size) {
  native_lower[i] <- quantile(native_runs[, i], 0.025)
  native_upper[i] <- quantile(native_runs[, i], ____)
  alien_lower[i] <- quantile(alien_runs[, i], ____)
  alien_upper[i] <- quantile(alien_runs[, i], 0.975)
}

# How much variation is there?
# Wie viel Variation gibt es?
midpoint <- sample_size %/% 2
native_cv <- round(100 * sd(native_runs[, midpoint]) / mean(native_runs[, midpoint]), 1)
alien_cv <- round(100 * sd(alien_runs[, midpoint]) / mean(alien_runs[, midpoint]), 1)

print("Variation at midpoint:")
print(paste("  Native CV:", native_cv, "%"))
print(paste("  Alien CV:", alien_cv, "%"))
```

### <span class="en">3c: Plot with uncertainty bands</span><span class="de">3c: Plotte mit Unsicherheitsb√§ndern</span>

```{r}
# Create summary data frame
# Erstelle Zusammenfassungs-Data-Frame
summary_data <- data.frame(
  plots = rep(1:sample_size, 2),
  mean = c(native_mean, alien_mean),
  lower = c(native_lower, alien_lower),
  upper = c(native_upper, alien_upper),
  status = rep(c("Native", "Alien"), each = sample_size)
)

# Plot with shaded confidence bands
# Plotte mit schattierten Konfidenzb√§ndern
ggplot(summary_data, aes(x = plots)) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = status), alpha = ____) +
  geom_line(aes(y = mean, color = status), linewidth = 1.2) +
  scale_color_manual(values = c("Native" = "darkgreen", "Alien" = "red")) +
  scale_fill_manual(values = c("Native" = "darkgreen", "Alien" = "red")) +
  labs(
    title = "Species Accumulation with Uncertainty",
    subtitle = paste(n_seeds, "starting points - shaded = 95% CI"),
    x = "Plots Sampled",
    y = "Cumulative Species",
    color = "", fill = ""
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

<div class="hint">
<span class="en">Hint: Use `mean` for the average. For 95% CI, upper bound is 0.975 quantile, lower is 0.025.</span>
<span class="de">Hinweis: Benutze `mean` f√ºr den Durchschnitt. F√ºr 95% CI ist obere Grenze 0.975 Quantil, untere 0.025.</span>
</div>

---

# <span class="en">Exercise 4: Comparing Saturation Speed</span><span class="de">√úbung 4: S√§ttigungsgeschwindigkeit vergleichen</span>

<div class="en">

**Concept:** **Saturation** is when we've found most of the species and the curve flattens. If natives saturate FASTER than aliens, it means natives are more evenly distributed (we find them everywhere). If aliens saturate SLOWER, they're more patchy (clustered in certain areas).

**New concept - Boxplots:**

`geom_boxplot()` shows the distribution of values:
- **Box** = middle 50% of data (25th to 75th percentile)
- **Line inside** = median (middle value)
- **Whiskers** = extend to ~1.5√ó the box height
- **Dots** = outliers (extreme values)

</div>

<div class="de">

**Konzept:** **S√§ttigung** ist wenn wir die meisten Arten gefunden haben und die Kurve abflacht. Wenn Heimische SCHNELLER saturieren, sind sie gleichm√§√üiger verteilt (wir finden sie √ºberall). Wenn Aliens LANGSAMER saturieren, sind sie fleckenhafter (in bestimmten Gebieten geclustert).

**Neues Konzept - Boxplots:**

`geom_boxplot()` zeigt die Verteilung von Werten:
- **Box** = mittlere 50% der Daten (25. bis 75. Perzentil)
- **Linie innen** = Median (mittlerer Wert)
- **Whiskers** = erstrecken sich ~1.5√ó die Boxh√∂he
- **Punkte** = Ausrei√üer (extreme Werte)

</div>

### <span class="en">4a: Find saturation points</span><span class="de">4a: Finde S√§ttigungspunkte</span>

```{r}
# At what point do we reach 80% of species?
# Bei welchem Punkt erreichen wir 80% der Arten?
native_sat <- numeric(n_seeds)
alien_sat <- numeric(n_seeds)

for (i in 1:n_seeds) {
  native_sat[i] <- find_saturation(native_runs[i, ], threshold = 0.8)
  alien_sat[i] <- find_saturation(alien_runs[i, ], threshold = ____)
}

# Convert to percentage of total plots
# In Prozent der Gesamtplots umwandeln
native_sat_pct <- 100 * native_sat / sample_size
alien_sat_pct <- 100 * alien_sat / sample_size

print("Plots needed to reach 80% of species:")
print(paste("  Native:", round(mean(native_sat_pct)), "% (SD:", round(sd(native_sat_pct), 1), ")"))
print(paste("  Alien:", round(mean(alien_sat_pct)), "% (SD:", round(sd(alien_sat_pct), 1), ")"))
```

### <span class="en">4b: Visualize with boxplot</span><span class="de">4b: Visualisiere mit Boxplot</span>

```{r}
# Create data for boxplot
# Erstelle Daten f√ºr Boxplot
sat_data <- data.frame(
  saturation_pct = c(native_sat_pct, alien_sat_pct),
  status = rep(c("Native", "Alien"), each = n_seeds)
)

ggplot(sat_data, aes(x = status, y = saturation_pct, fill = status)) +
  geom_boxplot() +
  scale_fill_manual(values = c("Native" = "____", "Alien" = "____")) +
  labs(
    title = "How Fast Do Species Saturate?",
    subtitle = "% of plots needed to find 80% of species",
    y = "% of Plots Needed",
    x = ""
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

### <span class="en">4c: Calculate slope ratio</span><span class="de">4c: Berechne Steigungsverh√§ltnis</span>

```{r}
# Compare early vs late slopes
# Vergleiche fr√ºhe vs sp√§te Steigungen
# High ratio = fast saturation (steep early, flat late)
# Hohes Verh√§ltnis = schnelle S√§ttigung (steil fr√ºh, flach sp√§t)

calc_slope_ratio <- function(curve) {
  n <- length(curve)
  early_end <- round(n * 0.2)
  late_start <- round(n * 0.8)

  early_slope <- (curve[early_end] - curve[1]) / early_end
  late_slope <- (curve[n] - curve[late_start]) / (n - late_start)

  if (late_slope > 0) return(early_slope / late_slope)
  else return(NA)
}

native_ratios <- numeric(n_seeds)
alien_ratios <- numeric(n_seeds)

for (i in 1:n_seeds) {
  native_ratios[i] <- calc_slope_ratio(native_runs[i, ])
  alien_ratios[i] <- calc_slope_ratio(alien_runs[i, ])
}

print("Slope ratio (higher = faster saturation):")
print(paste("  Native:", round(mean(native_ratios, na.rm = TRUE), 1)))
print(paste("  Alien:", round(mean(alien_ratios, na.rm = TRUE), 1)))
```

<div class="hint">
<span class="en">Hint: Fill in colors "darkgreen" and "red".</span>
<span class="de">Hinweis: F√ºlle Farben "darkgreen" und "red" ein.</span>
</div>

---

# <span class="en">Exercise 5: Geographic Patterns</span><span class="de">√úbung 5: Geografische Muster</span>

<div class="en">

**Concept:** Does it matter WHERE in Austria we start? Some areas might have more aliens (near cities, roads). Let's map how starting location affects what we find!

**New ggplot concepts for mapping:**

| Concept | What it does | Example |
|---------|--------------|---------|
| `coord_quickmap()` | Correct map proportions (so Austria doesn't look stretched!) | Add at end of ggplot |
| `scale_color_gradient2()` | Color scale with 3 colors (low‚Üímid‚Üíhigh) | `low="green", mid="yellow", high="red"` |
| `midpoint = value` | Where the middle color appears | `midpoint = 0.5` for 50% |

</div>

<div class="de">

**Konzept:** Ist es wichtig WO in √ñsterreich wir starten? Manche Gebiete haben vielleicht mehr Aliens (nahe St√§dten, Stra√üen). Kartieren wir wie der Startort beeinflusst was wir finden!

**Neue ggplot-Konzepte f√ºr Karten:**

| Konzept | Was es macht | Beispiel |
|---------|--------------|----------|
| `coord_quickmap()` | Korrekte Kartenproportion (damit √ñsterreich nicht gestreckt aussieht!) | Am Ende von ggplot hinzuf√ºgen |
| `scale_color_gradient2()` | Farbskala mit 3 Farben (niedrig‚Üímittel‚Üíhoch) | `low="green", mid="yellow", high="red"` |
| `midpoint = wert` | Wo die mittlere Farbe erscheint | `midpoint = 0.5` f√ºr 50% |

</div>

### <span class="en">5a: Map alien proportion by starting location</span><span class="de">5a: Kartiere Alien-Anteil nach Startort</span>

```{r}
# Test from 30 different starting locations
# Teste von 30 verschiedenen Startorten
n_map_seeds <- 30
checkpoint <- 75  # Check after this many plots

seed_results <- data.frame(
  seed_idx = 1:n_map_seeds,
  seed_lon = numeric(n_map_seeds),
  seed_lat = numeric(n_map_seeds),
  native_count = numeric(n_map_seeds),
  alien_count = numeric(n_map_seeds)
)

for (i in 1:n_map_seeds) {
  # Record starting location
  # Erfasse Startort
  seed_results$seed_lon[i] <- sample_header$Longitude[i]
  seed_results$seed_lat[i] <- sample_header$Latitude[i]

  # Run from this starting point
  # Starte von diesem Startpunkt
  nn_order <- nn_walk(sample_header, start_idx = i)

  # Get counts at checkpoint
  # Hole Z√§hlungen am Checkpoint
  native_curve <- build_accumulation(sample_species, nn_order, "nat")
  alien_curve <- build_accumulation(sample_species, nn_order, "neo")

  seed_results$native_count[i] <- native_curve[min(checkpoint, length(native_curve))]
  seed_results$alien_count[i] <- alien_curve[min(checkpoint, length(alien_curve))]
}

# Calculate alien proportion
# Berechne Alien-Anteil
seed_results$alien_prop <- seed_results$alien_count /
  (seed_results$native_count + seed_results$____)

# Map it!
# Kartiere es!
ggplot(seed_results, aes(x = seed_lon, y = seed_lat, color = alien_prop)) +
  geom_point(size = 4) +
  scale_color_gradient2(
    low = "darkgreen", mid = "yellow", high = "red",
    midpoint = mean(seed_results$alien_prop),
    name = "Alien\nproportion"
  ) +
  coord_quickmap() +
  labs(
    title = "How Starting Location Affects Alien Detection",
    subtitle = paste("Alien proportion after", checkpoint, "plots"),
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal()
```

<div class="hint">
<span class="en">Hint: Fill in `alien_count` to complete the proportion calculation.</span>
<span class="de">Hinweis: F√ºlle `alien_count` ein um die Anteilsberechnung zu vervollst√§ndigen.</span>
</div>

---

# <span class="en">Exercise 6: Putting It All Together</span><span class="de">√úbung 6: Alles zusammenf√ºgen</span>

<div class="en">

**Concept:** Let's put it all together and create a polished figure that shows our main finding: how native vs alien species accumulate differently across Austrian plots.

</div>

<div class="de">

**Konzept:** Fassen wir alles zusammen und erstellen eine sch√∂ne Abbildung die unser Hauptergebnis zeigt: wie heimische vs Alien-Arten unterschiedlich √ºber √∂sterreichische Plots akkumulieren.

</div>

### <span class="en">6a: Run full analysis</span><span class="de">6a: F√ºhre vollst√§ndige Analyse aus</span>

```{r}
# Larger sample for final analysis
# Gr√∂√üere Stichprobe f√ºr finale Analyse
n_seeds <- 30
sample_size <- 200

set.seed(2024)
sample_ids <- sample(unique(header$PlotObservationID), sample_size)
sample_header <- header %>% filter(PlotObservationID %in% sample_ids)
sample_species <- species %>% filter(PlotObservationID %in% sample_ids)

# Run from all seeds
# Starte von allen Seeds
native_runs <- matrix(NA, nrow = n_seeds, ncol = sample_size)
alien_runs <- matrix(NA, nrow = n_seeds, ncol = sample_size)

print("Running full analysis...")
for (seed in 1:n_seeds) {
  nn_order <- nn_walk(sample_header, start_idx = seed)
  native_runs[seed, ] <- build_accumulation(sample_species, nn_order, "nat")
  alien_runs[seed, ] <- build_accumulation(sample_species, nn_order, "neo")
  if (seed %% 10 == 0) print(paste("  Completed", seed, "of", n_seeds))
}
print("Done!")

# Calculate summaries using colMeans and loops
# Berechne Zusammenfassungen mit colMeans und Schleifen
native_mean <- colMeans(native_runs)
alien_mean <- colMeans(alien_runs)

native_lower <- numeric(sample_size)
native_upper <- numeric(sample_size)
alien_lower <- numeric(sample_size)
alien_upper <- numeric(sample_size)

for (i in 1:sample_size) {
  native_lower[i] <- quantile(native_runs[, i], 0.025)
  native_upper[i] <- quantile(native_runs[, i], 0.975)
  alien_lower[i] <- quantile(alien_runs[, i], 0.025)
  alien_upper[i] <- quantile(alien_runs[, i], 0.975)
}

results <- data.frame(
  plots = rep(1:sample_size, 2),
  mean = c(native_mean, alien_mean),
  lower = c(native_lower, alien_lower),
  upper = c(native_upper, alien_upper),
  status = rep(c("Native", "Alien"), each = sample_size)
)
```

### <span class="en">6b: Create polished figure</span><span class="de">6b: Erstelle sch√∂ne Abbildung</span>

```{r}
# Polished figure
# Sch√∂ne Abbildung
final_plot <- ggplot(results, aes(x = plots)) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = status), alpha = 0.25) +
  geom_line(aes(y = mean, color = status), linewidth = 1.3) +
  scale_color_manual(values = c("Native" = "#228B22", "Alien" = "#DC143C")) +
  scale_fill_manual(values = c("Native" = "#228B22", "Alien" = "#DC143C")) +
  labs(
    title = "Species Accumulation: Native vs Alien Plants in Austria",
    subtitle = paste0(n_seeds, " starting points, 95% confidence intervals"),
    x = "Number of Plots Sampled",
    y = "Cumulative Species Count",
    color = "", fill = ""
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = c(0.85, 0.2),
    legend.background = element_rect(fill = "white", color = "gray80"),
    plot.title = element_text(face = "bold")
  )

print(final_plot)

# Save it (uncomment to run)
# ggsave("austria_accumulation.png", final_plot, width = 10, height = 7, dpi = 300)
```

---

# <span class="en">Exercise 7: Interpret Your Results</span><span class="de">√úbung 7: Interpretiere deine Ergebnisse</span>

<div class="en">

**Concept:** Science isn't just about making plots - it's about understanding what they mean! Let's summarize our findings.

</div>

<div class="de">

**Konzept:** Wissenschaft bedeutet nicht nur Plots zu erstellen - es geht darum zu verstehen was sie bedeuten! Fassen wir unsere Ergebnisse zusammen.

</div>

### <span class="en">7a: Generate results summary</span><span class="de">7a: Generiere Ergebniszusammenfassung</span>

```{r}
print("========== RESULTS SUMMARY ==========")

# Total species found
print("Species found:")
print(paste("  Native:", round(mean(native_runs[, sample_size])), "species"))
print(paste("  Alien:", round(mean(alien_runs[, sample_size])), "species"))

# Saturation comparison (using a loop)
native_sat <- numeric(n_seeds)
alien_sat <- numeric(n_seeds)
for (i in 1:n_seeds) {
  native_sat[i] <- find_saturation(native_runs[i, ], threshold = 0.8)
  alien_sat[i] <- find_saturation(alien_runs[i, ], threshold = 0.8)
}

print("Plots to reach 80% of species:")
print(paste("  Native:", round(mean(native_sat)), "plots (",
    round(100*mean(native_sat)/sample_size), "%)"))
print(paste("  Alien:", round(mean(alien_sat)), "plots (",
    round(100*mean(alien_sat)/sample_size), "%)"))

# Draw conclusion
print("========== CONCLUSION ==========")
if (mean(native_sat) < mean(alien_sat)) {
  print("Native species saturate FASTER than aliens!")
  print("-> Natives are more evenly distributed")
  print("-> Aliens are more patchy/clustered")
} else {
  print("Aliens saturate FASTER than natives!")
  print("-> Aliens are more widespread than expected")
}
```

<blockquote>
<span class="en">**Discussion Questions:**
1. Do natives really saturate faster? What does this mean ecologically?
2. Why might aliens be more "patchy" (clustered in certain areas)?
3. What would you investigate next? (Urban areas? Elevation? Climate?)
</span>
<span class="de">**Diskussionsfragen:**
1. Saturieren Heimische wirklich schneller? Was bedeutet das √∂kologisch?
2. Warum k√∂nnten Aliens "fleckenhafter" sein (in bestimmten Gebieten geclustert)?
3. Was w√ºrdest du als n√§chstes untersuchen? (St√§dtische Gebiete? H√∂henlage? Klima?)
</span>
</blockquote>

---

# <span class="en">Quick Reference</span><span class="de">Schnellreferenz</span>

<div class="en">

| Function | Purpose | Example |
|----------|---------|---------|
| `colMeans()` | Mean of each column | `colMeans(mat)` |
| `quantile()` | Get percentiles | `quantile(x, 0.975)` |
| `geom_ribbon()` | Add shaded band | `+ geom_ribbon(aes(ymin, ymax))` |
| `scale_color_manual()` | Custom colors | `+ scale_color_manual(values = c(...))` |
| `scale_color_gradient2()` | Diverging color scale | `+ scale_color_gradient2(...)` |
| `ggsave()` | Save plot to file | `ggsave("plot.png", width = 10)` |
| `theme()` | Customize plot appearance | `+ theme(legend.position = "bottom")` |
| `element_rect()` | Rectangle element for themes | `element_rect(fill = "white")` |
| `element_text()` | Text element for themes | `element_text(face = "bold")` |

</div>

<div class="de">

| Funktion | Zweck | Beispiel |
|----------|-------|----------|
| `colMeans()` | Mittelwert jeder Spalte | `colMeans(mat)` |
| `quantile()` | Perzentile berechnen | `quantile(x, 0.975)` |
| `geom_ribbon()` | Schattiertes Band | `+ geom_ribbon(aes(ymin, ymax))` |
| `scale_color_manual()` | Eigene Farben | `+ scale_color_manual(values = c(...))` |
| `scale_color_gradient2()` | Divergierende Farbskala | `+ scale_color_gradient2(...)` |
| `ggsave()` | Plot in Datei speichern | `ggsave("plot.png", width = 10)` |
| `theme()` | Plot-Erscheinung anpassen | `+ theme(legend.position = "bottom")` |
| `element_rect()` | Rechteck-Element f√ºr Themes | `element_rect(fill = "white")` |
| `element_text()` | Text-Element f√ºr Themes | `element_text(face = "bold")` |

</div>
