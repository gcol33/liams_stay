---
title: '<span class="en">Day 2: Solutions</span><span class="de">Tag 2: Lösungen</span>'
subtitle: '<span class="en">Advanced Analysis & Research Project</span><span class="de">Fortgeschrittene Analyse & Forschungsprojekt</span>'
author: '<span class="en">Answer Key</span><span class="de">Lösungsschlüssel</span>'
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: flatly
    self_contained: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, message = FALSE, warning = FALSE)
```

```{=html}
<style>
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.7; background-color: #fafffe; }
h1 { color: #2E7D32 !important; border-bottom: 3px solid #4CAF50; padding-bottom: 10px; }
h2 { color: #388E3C !important; margin-top: 2em; }
h3 { color: #43A047 !important; }
pre { background-color: #f5f5f5 !important; border-left: 4px solid #4CAF50 !important; padding: 15px; border-radius: 8px; }
code { background-color: #E8F5E9; padding: 2px 6px; border-radius: 4px; color: #2E7D32; }
pre code { background-color: transparent; padding: 0; }
blockquote { border-left: 4px solid #FF9800; background-color: #FFF8E1; padding: 15px 20px; margin: 1em 0; border-radius: 0 8px 8px 0; }
hr { border: none; height: 3px; background: linear-gradient(to right, #4CAF50, #81C784, #C8E6C9, #81C784, #4CAF50); margin: 2em 0; }
.tocify { border: none !important; border-radius: 12px !important; background-color: #f1f8e9 !important; }
.tocify-item.active { background-color: #4CAF50 !important; color: white !important; }

.lang-toggle { position: fixed; top: 10px; right: 20px; z-index: 9999; background: linear-gradient(135deg, #2E7D32, #4CAF50); padding: 8px 12px; border-radius: 25px; }
.lang-toggle button { background: transparent; border: none; color: #fff; padding: 6px 14px; cursor: pointer; font-weight: bold; border-radius: 20px; font-size: 14px; }
.lang-toggle button.active { background: white; color: #2E7D32; }
.de { display: none; } .en { display: inline; }
body.lang-de .de { display: inline; } body.lang-de .en { display: none; }
div.de, p.de, li.de, h1.de, h2.de, h3.de, section.de { display: none; }
div.en, p.en, li.en, h1.en, h2.en, h3.en, section.en { display: block; }
body.lang-de div.de, body.lang-de p.de, body.lang-de li.de, body.lang-de h1.de, body.lang-de h2.de, body.lang-de h3.de, body.lang-de section.de { display: block; }
body.lang-de div.en, body.lang-de p.en, body.lang-de li.en, body.lang-de h1.en, body.lang-de h2.en, body.lang-de h3.en, body.lang-de section.en { display: none; }
body.lang-de #TOC .en { display: none; } body.lang-de #TOC .de { display: inline; }
#TOC .de { display: none; } #TOC .en { display: inline; }

@media (max-width: 768px) {
  body { font-size: 14px; }
  pre { font-size: 11px; padding: 10px; }
}
</style>
```

```{=html}
<script>
$(document).ready(function() {
  var toggle = $('<div class="lang-toggle"><button id="btn-en" class="active">EN</button><button id="btn-de">DE</button></div>');
  $('body').append(toggle);
  var savedLang = localStorage.getItem('workshop-lang');
  var defaultLang = savedLang || (navigator.language.substring(0, 2) === 'de' ? 'de' : 'en');
  function setLanguage(lang) {
    $('body').removeClass('lang-en lang-de').addClass('lang-' + lang);
    $('#btn-en').toggleClass('active', lang === 'en');
    $('#btn-de').toggleClass('active', lang === 'de');
    localStorage.setItem('workshop-lang', lang);
  }
  if (defaultLang === 'de') setLanguage('de');
  $('#btn-en').click(function() { setLanguage('en'); });
  $('#btn-de').click(function() { setLanguage('de'); });
});
</script>
```

---

# <span class="en">Exercise 1: Setup - Load Data and Functions</span><span class="de">Übung 1: Setup - Daten und Funktionen laden</span>

### <span class="en">1a: Load libraries and data</span><span class="de">1a: Bibliotheken und Daten laden</span>

```{r}
library(tidyverse)

header <- read_csv("../data/austria_header.csv")
species <- read_csv("../data/austria_species.csv")

nrow(header)
nrow(species)
```

### <span class="en">1b: Copy all helper functions</span><span class="de">1b: Alle Hilfsfunktionen kopieren</span>

<div class="en">

**Code Philosophy:** These functions follow key programming principles:

1. **Single responsibility** - Each function does ONE thing well
2. **Reusability** - Functions are generic, not hardcoded to specific data
3. **Vectorization** - Use R's strength: operate on whole vectors at once
4. **Sensible defaults** - Optional parameters have reasonable default values

</div>

<div class="de">

**Code-Philosophie:** Diese Funktionen folgen wichtigen Programmierprinzipien:

1. **Einzelverantwortung** - Jede Funktion macht EINE Sache gut
2. **Wiederverwendbarkeit** - Funktionen sind generisch, nicht auf bestimmte Daten festgelegt
3. **Vektorisierung** - Nutze Rs Stärke: operiere auf ganzen Vektoren gleichzeitig
4. **Sinnvolle Standardwerte** - Optionale Parameter haben vernünftige Standardwerte

</div>

```{r}
# ==== FUNCTION 1: calc_distance ====
# Calculates Euclidean distance. VECTORIZED: x2,y2 can be vectors!
# Berechnet Euklidische Distanz. VEKTORISIERT: x2,y2 können Vektoren sein!

calc_distance <- function(x1, y1, x2, y2) {
  # Pythagorean theorem: sqrt(dx² + dy²). Works with vectors!
  # Satz des Pythagoras: sqrt(dx² + dy²). Funktioniert mit Vektoren!
  sqrt((x2 - x1)^2 + (y2 - y1)^2)
}


# ==== FUNCTION 2: nn_walk ====
# Nearest-neighbour walk: always go to closest unvisited plot
# Nearest-Neighbour-Walk: gehe immer zum nächsten unbesuchten Plot

nn_walk <- function(header_data, start_idx = NULL) {
  # How many plots total? / Wie viele Plots insgesamt?
  n <- nrow(header_data)

  # If no start given, pick random / Wenn kein Start, wähle zufällig
  if (is.null(start_idx)) start_idx <- sample(1:n, 1)

  # Track which plots we've visited / Verfolge welche Plots besucht
  visited <- rep(FALSE, n)
  # Store the order we visit them / Speichere Reihenfolge
  visit_order <- numeric(n)
  # Start at this plot / Starte bei diesem Plot
  current <- start_idx

  # Loop through all plots / Schleife durch alle Plots
  for (i in 1:n) {
    # Mark current as visited / Markiere aktuellen als besucht
    visited[current] <- TRUE
    # Save the plot ID / Speichere Plot-ID
    visit_order[i] <- header_data$PlotObservationID[current]

    # If not done yet / Falls noch nicht fertig
    if (i < n) {
      # Calculate distance from current to ALL others (vectorized!)
      # Berechne Distanz von aktuellem zu ALLEN anderen (vektorisiert!)
      distances <- calc_distance(
        header_data$Longitude[current],
        header_data$Latitude[current],
        header_data$Longitude,
        header_data$Latitude
      )
      # Inf trick: visited plots can never be "minimum"
      # Inf-Trick: besuchte Plots können nie "Minimum" sein
      distances[visited] <- Inf
      # Go to closest unvisited / Gehe zum nächsten unbesuchten
      current <- which.min(distances)
    }
  }
  # Return the order of plot IDs / Gib Reihenfolge der Plot-IDs zurück
  return(visit_order)
}


# ==== FUNCTION 3: build_accumulation ====
# Count cumulative species as we visit each plot in order
# Zähle kumulative Arten während wir jeden Plot der Reihe nach besuchen

build_accumulation <- function(species_data, plot_order, status_filter = NULL) {
  # If filter provided (e.g., "nat"), keep only matching species
  # Falls Filter angegeben, behalte nur passende Arten
  if (!is.null(status_filter)) {
    species_data <- species_data %>% filter(STATUS == status_filter)
  }

  # Empty vector to collect all species found / Leerer Vektor für gefundene Arten
  found <- c()
  # Pre-allocate result vector / Ergebnisvektor vorbelegen
  accum <- numeric(length(plot_order))

  # For each plot in our walking order / Für jeden Plot in unserer Laufreihenfolge
  for (i in seq_along(plot_order)) {
    # Get unique species in this plot / Hole einzigartige Arten in diesem Plot
    plot_spp <- species_data %>%
      # Filter to current plot / Filtere auf aktuellen Plot
      filter(PlotObservationID == plot_order[i]) %>%
      # Extract species names / Extrahiere Artnamen
      pull(WFO_TAXON) %>%
      # Remove duplicates within plot / Entferne Duplikate im Plot
      unique()

    # setdiff: what's NEW? (in plot but not yet found)
    # setdiff: was ist NEU? (im Plot aber noch nicht gefunden)
    new_spp <- setdiff(plot_spp, found)
    # Add new species to our collection / Füge neue Arten zur Sammlung
    found <- c(found, new_spp)
    # Count total species so far / Zähle Gesamtarten bisher
    accum[i] <- length(found)
  }
  # Return the accumulation curve / Gib Akkumulationskurve zurück
  return(accum)
}


# ==== FUNCTION 4: find_saturation ====
# Find when we reach X% of total species (default 80%)
# Finde wann wir X% der Gesamtarten erreichen (Standard 80%)

find_saturation <- function(curve, threshold = 0.8) {
  # Calculate target: 80% of final count / Berechne Ziel: 80% der Endzahl
  target <- max(curve) * threshold
  # which()[1] = first position where TRUE / Erste Position wo TRUE
  which(curve >= target)[1]
}

cat("All functions loaded!\n")
```

```{=html}
<!-- Hidden Rcpp section - only visible when toggled -->
<style>
.rcpp-section {
  display: none;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #e94560;
  border-radius: 12px;
  padding: 20px;
  margin: 1.5em 0;
  color: #eee;
}
.rcpp-section.visible { display: block; }
.rcpp-section h4 { color: #e94560 !important; border: none; margin-top: 0; }
.rcpp-section code { background-color: #0f3460; color: #00ff88; }
.rcpp-section pre { background-color: #0f3460 !important; border-left-color: #e94560 !important; }
.rcpp-section pre code { color: #00ff88; }
.rcpp-toggle {
  background: linear-gradient(135deg, #e94560, #c23a5a);
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  font-weight: bold;
  font-size: 12px;
  margin: 0.5em 0;
}
.rcpp-toggle:hover { background: linear-gradient(135deg, #c23a5a, #a02040); }
</style>

<button class="rcpp-toggle" onclick="document.getElementById('rcpp-turbo').classList.toggle('visible')">
  ⚡ Turbo Mode: Show/Hide Rcpp Functions
</button>

<div id="rcpp-turbo" class="rcpp-section">
<h4>⚡ Rcpp Turbo Functions (if R is too slow)</h4>

<p><span class="en">If analyses take too long, these C++ versions are 10-50x faster. Run this ONCE at the start to replace the R functions:</span><span class="de">Falls Analysen zu lange dauern, sind diese C++ Versionen 10-50x schneller. Führe dies EINMAL am Anfang aus um die R-Funktionen zu ersetzen:</span></p>

<pre><code class="r"># Install Rcpp if needed / Installiere Rcpp falls nötig
# install.packages("Rcpp")
library(Rcpp)

# Compile the C++ functions / Kompiliere die C++ Funktionen
cppFunction('
NumericVector nn_walk_cpp(NumericVector lon, NumericVector lat, IntegerVector plot_ids, int start_idx) {
  int n = lon.size();
  NumericVector visit_order(n);
  LogicalVector visited(n, false);

  int current = start_idx - 1;  // Convert to 0-indexed

  for (int i = 0; i &lt; n; i++) {
    visited[current] = true;
    visit_order[i] = plot_ids[current];

    if (i &lt; n - 1) {
      double min_dist = R_PosInf;
      int next_idx = -1;

      for (int j = 0; j &lt; n; j++) {
        if (!visited[j]) {
          double dx = lon[j] - lon[current];
          double dy = lat[j] - lat[current];
          double dist = sqrt(dx*dx + dy*dy);
          if (dist &lt; min_dist) {
            min_dist = dist;
            next_idx = j;
          }
        }
      }
      current = next_idx;
    }
  }
  return visit_order;
}
')

cppFunction('
IntegerVector build_accum_cpp(IntegerVector plot_obs_id, IntegerVector taxon_id,
                               IntegerVector plot_order) {
  int n_plots = plot_order.size();
  IntegerVector accum(n_plots);
  std::set&lt;int&gt; found_species;

  for (int i = 0; i &lt; n_plots; i++) {
    int target_plot = plot_order[i];

    for (int j = 0; j &lt; plot_obs_id.size(); j++) {
      if (plot_obs_id[j] == target_plot) {
        found_species.insert(taxon_id[j]);
      }
    }
    accum[i] = found_species.size();
  }
  return accum;
}
', includes = "#include &lt;set&gt;")

# Wrapper function for nn_walk (drop-in replacement)
nn_walk_fast &lt;- function(header_data, start_idx = NULL) {
  if (is.null(start_idx)) start_idx &lt;- sample(1:nrow(header_data), 1)
  nn_walk_cpp(header_data$Longitude, header_data$Latitude,
              header_data$PlotObservationID, start_idx)
}

# Wrapper for build_accumulation (requires pre-processing)
build_accumulation_fast &lt;- function(species_data, plot_order, status_filter = NULL) {
  if (!is.null(status_filter)) {
    species_data &lt;- species_data[species_data$STATUS == status_filter, ]
  }
  taxon_factor &lt;- as.integer(factor(species_data$WFO_TAXON))
  build_accum_cpp(species_data$PlotObservationID, taxon_factor, as.integer(plot_order))
}

# Replace the R functions
nn_walk &lt;- nn_walk_fast
build_accumulation &lt;- build_accumulation_fast

cat("⚡ Rcpp turbo mode activated! Functions are now 10-50x faster.\n")
</code></pre>

<p style="font-size: 0.85em; color: #aaa;"><span class="en">Note: Requires Rcpp package and a C++ compiler (Rtools on Windows).</span><span class="de">Hinweis: Benötigt Rcpp-Paket und einen C++ Compiler (Rtools unter Windows).</span></p>
</div>
```

---

# <span class="en">Exercise 2: Understanding Spatial Sampling</span><span class="de">Übung 2: Räumliches Sampling verstehen</span>

### <span class="en">2a: Create a sample dataset</span><span class="de">2a: Erstelle einen Beispieldatensatz</span>

```{r}
set.seed(42)
sample_size <- 150
sample_ids <- sample(unique(header$PlotObservationID), sample_size)
sample_header <- header %>% filter(PlotObservationID %in% sample_ids)
sample_species <- species %>% filter(PlotObservationID %in% sample_ids)

nrow(sample_header)
```

### <span class="en">2b: Run your first spatial walk</span><span class="de">2b: Führe deinen ersten räumlichen Walk aus</span>

```{r}
nn_order <- nn_walk(sample_header, start_idx = 1)
head(nn_order, 10)
```

### <span class="en">2c: Build accumulation curves</span><span class="de">2c: Baue Akkumulationskurven</span>

```{r}
native_curve <- build_accumulation(sample_species, nn_order, "nat")
alien_curve <- build_accumulation(sample_species, nn_order, "neo")

# Quick plot
plot(native_curve, type = "l", col = "darkgreen", lwd = 2,
     xlab = "Plots", ylab = "Species")
lines(alien_curve, col = "red", lwd = 2)
legend("bottomright", c("Native", "Alien"), col = c("darkgreen", "red"), lwd = 2)
```

---

# <span class="en">Exercise 3: Measuring Uncertainty</span><span class="de">Übung 3: Unsicherheit messen</span>

### <span class="en">3a: Run multiple walks from different starting points</span><span class="de">3a: Führe mehrere Walks von verschiedenen Startpunkten aus</span>

```{r}
n_seeds <- 20

native_runs <- matrix(NA, nrow = n_seeds, ncol = sample_size)
alien_runs <- matrix(NA, nrow = n_seeds, ncol = sample_size)

cat("Running", n_seeds, "walks...\n")
for (seed in 1:n_seeds) {
  nn_order <- nn_walk(sample_header, start_idx = seed)
  native_runs[seed, ] <- build_accumulation(sample_species, nn_order, "nat")
  alien_runs[seed, ] <- build_accumulation(sample_species, nn_order, "neo")

  if (seed %% 5 == 0) cat("  Completed walk", seed, "\n")
}
cat("Done!\n")
```

### <span class="en">3b: Calculate mean and 95% confidence intervals</span><span class="de">3b: Berechne Mittelwert und 95% Konfidenzintervalle</span>

```{r}
native_mean <- apply(native_runs, 2, mean)
native_lower <- apply(native_runs, 2, function(x) quantile(x, 0.025))
native_upper <- apply(native_runs, 2, function(x) quantile(x, 0.975))

alien_mean <- apply(alien_runs, 2, mean)
alien_lower <- apply(alien_runs, 2, function(x) quantile(x, 0.025))
alien_upper <- apply(alien_runs, 2, function(x) quantile(x, 0.975))

# Variation at midpoint
midpoint <- sample_size %/% 2
native_cv <- round(100 * sd(native_runs[, midpoint]) / mean(native_runs[, midpoint]), 1)
alien_cv <- round(100 * sd(alien_runs[, midpoint]) / mean(alien_runs[, midpoint]), 1)

print(paste("Variation at", midpoint, "plots:"))
print(paste("  Native CV:", native_cv, "%"))
print(paste("  Alien CV:", alien_cv, "%"))
```

### <span class="en">3c: Plot curves with uncertainty bands</span><span class="de">3c: Plotte Kurven mit Unsicherheitsbändern</span>

```{r}
summary_data <- data.frame(
  plots = rep(1:sample_size, 2),
  mean = c(native_mean, alien_mean),
  lower = c(native_lower, alien_lower),
  upper = c(native_upper, alien_upper),
  status = rep(c("Native", "Alien"), each = sample_size)
)

ggplot(summary_data, aes(x = plots)) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = status), alpha = 0.3) +
  geom_line(aes(y = mean, color = status), linewidth = 1.2) +
  scale_color_manual(values = c("Native" = "darkgreen", "Alien" = "red")) +
  scale_fill_manual(values = c("Native" = "darkgreen", "Alien" = "red")) +
  labs(
    title = "Species Accumulation with Uncertainty",
    subtitle = paste(n_seeds, "starting points - shaded area = 95% CI"),
    x = "Plots Sampled",
    y = "Cumulative Species"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

---

# <span class="en">Exercise 4: Comparing Saturation Speed</span><span class="de">Übung 4: Sättigungsgeschwindigkeit vergleichen</span>

### <span class="en">4a: Find 80% saturation points</span><span class="de">4a: Finde 80% Sättigungspunkte</span>

```{r}
native_sat <- apply(native_runs, 1, find_saturation, threshold = 0.8)
alien_sat <- apply(alien_runs, 1, find_saturation, threshold = 0.8)

native_sat_pct <- 100 * native_sat / sample_size
alien_sat_pct <- 100 * alien_sat / sample_size

print("Plots needed to reach 80% of species:")
print(paste("  Native:", round(mean(native_sat_pct)), "% (SD:", round(sd(native_sat_pct), 1), ")"))
print(paste("  Alien:", round(mean(alien_sat_pct)), "% (SD:", round(sd(alien_sat_pct), 1), ")"))
```

### <span class="en">4b: Create a comparison boxplot</span><span class="de">4b: Erstelle einen Vergleichs-Boxplot</span>

```{r}
sat_data <- data.frame(
  saturation_pct = c(native_sat_pct, alien_sat_pct),
  status = rep(c("Native", "Alien"), each = n_seeds)
)

ggplot(sat_data, aes(x = status, y = saturation_pct, fill = status)) +
  geom_boxplot() +
  scale_fill_manual(values = c("Native" = "darkgreen", "Alien" = "red")) +
  labs(
    title = "Saturation Speed Comparison",
    subtitle = "% of plots needed to find 80% of species",
    y = "% of Plots Needed",
    x = ""
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

### <span class="en">4c: Scientific interpretation</span><span class="de">4c: Wissenschaftliche Interpretation</span>

```{r}
if (mean(native_sat) < mean(alien_sat)) {
  cat("Native species saturate FASTER!\n")
  cat("This means: we encounter most native species quickly across the landscape.\n")
  cat("Different alien species occur in different regions — high spatial turnover.\n")
} else {
  cat("Alien species saturate FASTER!\n")
  cat("This is unusual - aliens may be more widespread than expected.\n")
}
```

---

# <span class="en">Exercise 5: Geographic Patterns</span><span class="de">Übung 5: Geografische Muster</span>

### <span class="en">5a: Map how starting location affects results</span><span class="de">5a: Kartiere wie der Startort die Ergebnisse beeinflusst</span>

```{r}
n_map_seeds <- 30
checkpoint <- 75

seed_results <- data.frame(
  seed_idx = 1:n_map_seeds,
  seed_lon = numeric(n_map_seeds),
  seed_lat = numeric(n_map_seeds),
  native_count = numeric(n_map_seeds),
  alien_count = numeric(n_map_seeds)
)

for (i in 1:n_map_seeds) {
  seed_results$seed_lon[i] <- sample_header$Longitude[i]
  seed_results$seed_lat[i] <- sample_header$Latitude[i]

  nn_order <- nn_walk(sample_header, start_idx = i)

  native_curve <- build_accumulation(sample_species, nn_order, "nat")
  alien_curve <- build_accumulation(sample_species, nn_order, "neo")

  seed_results$native_count[i] <- native_curve[min(checkpoint, length(native_curve))]
  seed_results$alien_count[i] <- alien_curve[min(checkpoint, length(alien_curve))]
}

seed_results$alien_prop <- seed_results$alien_count /
  (seed_results$native_count + seed_results$alien_count)

# Map it!
ggplot(seed_results, aes(x = seed_lon, y = seed_lat, color = alien_prop)) +
  geom_point(size = 4) +
  scale_color_gradient2(
    low = "darkgreen", mid = "yellow", high = "red",
    midpoint = mean(seed_results$alien_prop),
    name = "Alien\nproportion"
  ) +
  coord_quickmap() +
  labs(
    title = "How Starting Location Affects Alien Detection",
    subtitle = paste("Alien proportion after", checkpoint, "plots"),
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal()

# Correlation with geography
cor_lon <- cor(seed_results$seed_lon, seed_results$alien_prop)
cor_lat <- cor(seed_results$seed_lat, seed_results$alien_prop)

print(paste("Correlation with longitude:", round(cor_lon, 3)))
print(paste("Correlation with latitude:", round(cor_lat, 3)))
```

---

# <span class="en">Exercise 6: Final Publication Plot</span><span class="de">Übung 6: Finaler Publikationsplot</span>

### <span class="en">6a: Run full analysis with more seeds</span><span class="de">6a: Führe vollständige Analyse mit mehr Seeds aus</span>

```{r}
n_seeds <- 30
sample_size <- 250

set.seed(2024)
sample_ids <- sample(unique(header$PlotObservationID), sample_size)
sample_header <- header %>% filter(PlotObservationID %in% sample_ids)
sample_species <- species %>% filter(PlotObservationID %in% sample_ids)

native_runs <- matrix(NA, nrow = n_seeds, ncol = sample_size)
alien_runs <- matrix(NA, nrow = n_seeds, ncol = sample_size)

cat("Running full analysis...\n")
for (seed in 1:n_seeds) {
  nn_order <- nn_walk(sample_header, start_idx = seed)
  native_runs[seed, ] <- build_accumulation(sample_species, nn_order, "nat")
  alien_runs[seed, ] <- build_accumulation(sample_species, nn_order, "neo")
  if (seed %% 10 == 0) cat("  Completed", seed, "of", n_seeds, "\n")
}
cat("Done!\n")

results <- data.frame(
  plots = rep(1:sample_size, 2),
  mean = c(apply(native_runs, 2, mean), apply(alien_runs, 2, mean)),
  lower = c(apply(native_runs, 2, function(x) quantile(x, 0.025)),
            apply(alien_runs, 2, function(x) quantile(x, 0.025))),
  upper = c(apply(native_runs, 2, function(x) quantile(x, 0.975)),
            apply(alien_runs, 2, function(x) quantile(x, 0.975))),
  status = rep(c("Native", "Alien"), each = sample_size)
)
```

### <span class="en">6b: Create the publication-quality figure</span><span class="de">6b: Erstelle die publikationsreife Abbildung</span>

```{r}
final_plot <- ggplot(results, aes(x = plots)) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = status), alpha = 0.25) +
  geom_line(aes(y = mean, color = status), linewidth = 1.3) +
  scale_color_manual(
    values = c("Native" = "#228B22", "Alien" = "#DC143C"),
    name = ""
  ) +
  scale_fill_manual(
    values = c("Native" = "#228B22", "Alien" = "#DC143C"),
    name = ""
  ) +
  labs(
    title = "Species Accumulation: Native vs Alien Plants",
    subtitle = paste0("Nearest-neighbour sampling from ", n_seeds, " starting points (95% CI shown)"),
    x = "Number of Plots Sampled",
    y = "Cumulative Species Count",
    caption = "Data: Austrian vegetation plots"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = c(0.85, 0.2),
    legend.background = element_rect(fill = "white", color = "gray80"),
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )

print(final_plot)

# Save to file (uncomment to run)
# ggsave("austria_accumulation_final.png", final_plot, width = 10, height = 7, dpi = 300)
```

---

# <span class="en">Exercise 7: Interpret Your Results</span><span class="de">Übung 7: Interpretiere deine Ergebnisse</span>

### <span class="en">7a: Write your scientific conclusions</span><span class="de">7a: Schreibe deine wissenschaftlichen Schlussfolgerungen</span>

```{r}
cat("\n===== RESULTS SUMMARY =====\n\n")

cat("Species found:\n")
cat("  Native:", round(mean(native_runs[, sample_size])),
    "(range:", min(native_runs[, sample_size]), "-", max(native_runs[, sample_size]), ")\n")
cat("  Alien:", round(mean(alien_runs[, sample_size])),
    "(range:", min(alien_runs[, sample_size]), "-", max(alien_runs[, sample_size]), ")\n\n")

native_sat <- apply(native_runs, 1, find_saturation, threshold = 0.8)
alien_sat <- apply(alien_runs, 1, find_saturation, threshold = 0.8)

cat("Plots to reach 80% of species:\n")
cat("  Native:", round(mean(native_sat)), "plots (",
    round(100*mean(native_sat)/sample_size), "%)\n")
cat("  Alien:", round(mean(alien_sat)), "plots (",
    round(100*mean(alien_sat)/sample_size), "%)\n\n")

cat("===== ECOLOGICAL CONCLUSIONS =====\n\n")

if (mean(native_sat) < mean(alien_sat)) {
  cat("FINDING: Native species saturate FASTER than aliens.\n\n")
  cat("INTERPRETATION:\n")
  cat("- We encounter most native species quickly as we move across the landscape\n")
  cat("- Alien species show high spatial turnover — different aliens in different regions\n")
  cat("- This is consistent with invasion biology theory:\n")
  cat("  different introduction pathways bring different species to different areas\n")
  cat("  (e.g. garden escapes vs. agricultural weeds vs. transport corridors)\n\n")
} else {
  cat("FINDING: Alien species saturate FASTER than natives.\n\n")
  cat("INTERPRETATION:\n")
  cat("- This is unexpected - aliens may be more widespread than expected\n")
  cat("- Possible explanations:\n")
  cat("  1. Advanced invasion stage in this region\n")
  cat("  2. Many 'naturalized' aliens now broadly distributed\n")
  cat("  3. Sample bias toward accessible (more invaded) areas\n\n")
}

cat("===== WORKSHOP COMPLETE! =====\n")
cat("You have learned:\n")
cat("1. R basics: vectors, dataframes, functions\n")
cat("2. Data manipulation with dplyr\n")
cat("3. Visualization with ggplot2\n")
cat("4. Spatial algorithms (nearest-neighbour)\n")
cat("5. Uncertainty quantification\n")
cat("6. Scientific interpretation of results\n")
```

---

<div class="en">

**Key concepts from Day 2:**

- **Uncertainty quantification**: Running multiple analyses to measure variability
- **Confidence intervals**: The range where the "true" value likely falls
- **Saturation speed**: How quickly you find most species
- **Spatial patterns**: How species distribution varies across geography
- **Scientific interpretation**: Connecting data patterns to ecological theory

</div>

<div class="de">

**Schlüsselkonzepte von Tag 2:**

- **Unsicherheitsquantifizierung**: Mehrere Analysen durchführen, um Variabilität zu messen
- **Konfidenzintervalle**: Der Bereich, in dem der "wahre" Wert wahrscheinlich liegt
- **Sättigungsgeschwindigkeit**: Wie schnell man die meisten Arten findet
- **Räumliche Muster**: Wie die Artenverteilung über die Geografie variiert
- **Wissenschaftliche Interpretation**: Datenmuster mit ökologischer Theorie verbinden

</div>
