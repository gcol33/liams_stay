---
title: '<span class="en">Code Exercises</span><span class="de">Code-Ubungen</span>'
subtitle: '<span class="en">Species Accumulation Curves Workshop</span><span class="de">Artenakkumulationskurven Workshop</span>'
author: '<span class="en">Fill in the blanks!</span><span class="de">Fulle die Lucken aus!</span>'
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: flatly
    self_contained: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, message = FALSE, warning = FALSE)
```

```{=html}
<style>
/* ========== PLAYFUL WORKSHOP THEME ========== */

body {
 font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
 line-height: 1.7;
 background-color: #fafffe;
}

h1 {
 color: #2E7D32 !important;
 border-bottom: 3px solid #4CAF50;
 padding-bottom: 10px;
}

h2 {
 color: #388E3C !important;
 margin-top: 2em;
}

h3 {
 color: #43A047 !important;
}

h4 {
 color: #66BB6A !important;
 border-left: 4px solid #4CAF50;
 padding-left: 10px;
}

/* Code blocks with copy button support */
pre {
 background-color: #f5f5f5 !important;
 border-left: 4px solid #4CAF50 !important;
 padding: 15px;
 padding-top: 35px;
 border-radius: 8px;
 overflow-x: auto;
 position: relative !important;
}

code {
 background-color: #E8F5E9;
 padding: 2px 6px;
 border-radius: 4px;
 color: #2E7D32;
}

pre code {
 background-color: transparent;
 padding: 0;
}

/* Copy button styling */
.copy-btn {
 position: absolute !important;
 top: 8px !important;
 right: 8px !important;
 padding: 4px 12px;
 font-size: 12px;
 background: #4CAF50;
 color: white;
 border: none;
 border-radius: 4px;
 cursor: pointer;
 opacity: 0;
 transition: opacity 0.2s, background 0.2s;
 z-index: 100;
}

pre:hover .copy-btn {
 opacity: 1;
}

.copy-btn:hover {
 background: #2E7D32;
}

.copy-btn.copied {
 background: #1976D2;
}

blockquote {
 border-left: 4px solid #FF9800;
 background-color: #FFF8E1;
 padding: 15px 20px;
 margin: 1em 0;
 border-radius: 0 8px 8px 0;
}

hr {
 border: none;
 height: 3px;
 background: linear-gradient(to right, #4CAF50, #81C784, #C8E6C9, #81C784, #4CAF50);
 margin: 2em 0;
 border-radius: 2px;
}

.tocify {
 border: none !important;
 border-radius: 12px !important;
 background-color: #f1f8e9 !important;
 box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.tocify-item.active, .tocify-item.active:hover {
 background-color: #4CAF50 !important;
 color: white !important;
}

/* Exercise hint */
.hint {
 background-color: #E3F2FD;
 border: 1px solid #1976D2;
 border-radius: 8px;
 padding: 10px 15px;
 margin: 1em 0;
 font-size: 0.9em;
}

.hint::before {
 content: "ðŸ’¡ ";
}

/* ========== LANGUAGE TOGGLE ========== */

.lang-toggle {
 position: fixed;
 top: 10px;
 right: 20px;
 z-index: 9999;
 background: linear-gradient(135deg, #2E7D32, #4CAF50);
 padding: 8px 12px;
 border-radius: 25px;
 box-shadow: 0 4px 15px rgba(46, 125, 50, 0.3);
}

.lang-toggle button {
 background: transparent;
 border: none;
 color: #fff;
 padding: 6px 14px;
 cursor: pointer;
 font-weight: bold;
 border-radius: 20px;
 transition: all 0.3s;
 font-size: 14px;
}

.lang-toggle button.active {
 background: white;
 color: #2E7D32;
}

.lang-toggle button:hover:not(.active) {
 background: rgba(255,255,255,0.2);
}

.de { display: none; }
.en { display: inline; }

body.lang-de .de { display: inline; }
body.lang-de .en { display: none; }

div.de, p.de, li.de, h1.de, h2.de, h3.de, h4.de, section.de { display: none; }
div.en, p.en, li.en, h1.en, h2.en, h3.en, h4.en, section.en { display: block; }

body.lang-de div.de, body.lang-de p.de, body.lang-de li.de,
body.lang-de h1.de, body.lang-de h2.de, body.lang-de h3.de,
body.lang-de h4.de, body.lang-de section.de { display: block; }

body.lang-de div.en, body.lang-de p.en, body.lang-de li.en,
body.lang-de h1.en, body.lang-de h2.en, body.lang-de h3.en,
body.lang-de h4.en, body.lang-de section.en { display: none; }

body.lang-de #TOC .en { display: none; }
body.lang-de #TOC .de { display: inline; }
#TOC .de { display: none; }
#TOC .en { display: inline; }

@media print {
 .tocify, .lang-toggle, .copy-btn { display: none; }
}
</style>
```

```{=html}
<script>
$(document).ready(function() {
  // Language toggle
  var toggle = $('<div class="lang-toggle"><button id="btn-en" class="active">EN</button><button id="btn-de">DE</button></div>');
  $('body').append(toggle);

  var savedLang = localStorage.getItem('workshop-lang');
  var browserLang = navigator.language.substring(0, 2);
  var defaultLang = savedLang || (browserLang === 'de' ? 'de' : 'en');

  function setLanguage(lang) {
    $('body').removeClass('lang-en lang-de').addClass('lang-' + lang);
    $('#btn-en').toggleClass('active', lang === 'en');
    $('#btn-de').toggleClass('active', lang === 'de');
    localStorage.setItem('workshop-lang', lang);
  }

  if (defaultLang === 'de') {
    setLanguage('de');
  }

  $('#btn-en').click(function() { setLanguage('en'); });
  $('#btn-de').click(function() { setLanguage('de'); });

  // Copy button for code blocks
  $('pre').each(function() {
    var pre = $(this);
    var btn = $('<button class="copy-btn">Copy</button>');

    btn.click(function() {
      var code = pre.find('code');
      var text = code.length ? code.text() : pre.text();

      function showSuccess() {
        btn.text('Copied!').addClass('copied');
        setTimeout(function() {
          btn.text('Copy').removeClass('copied');
        }, 2000);
      }

      function fallbackCopy() {
        var textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        try {
          document.execCommand('copy');
          showSuccess();
        } catch(e) {
          btn.text('Failed');
        }
        document.body.removeChild(textarea);
      }

      // Use clipboard API if available and in secure context, else fallback
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text).then(showSuccess).catch(fallbackCopy);
      } else {
        fallbackCopy();
      }
    });

    pre.css('position', 'relative').append(btn);
  });
});
</script>
```

---

# <span class="en">Part 1: R Basics</span><span class="de">Teil 1: R Grundlagen</span>

## <span class="en">Exercise 1: Variables and Vectors</span><span class="de">Ubung 1: Variablen und Vektoren</span>

<div class="en">

**Task:** Create variables and vectors, then perform basic operations.

</div>

<div class="de">

**Aufgabe:** Erstelle Variablen und Vektoren, dann fuhre grundlegende Operationen aus.

</div>

```{r}
# Exercise 1: Variables and Vectors
# Ubung 1: Variablen und Vektoren

# 1. Create a variable with your favorite number
my_number <- ____

# 2. Create a vector with 5 numbers
my_vector <- c(____, ____, ____, ____, ____)

# 3. Calculate the sum of the vector
total <- ____(my_vector)
print(total)

# 4. Calculate the mean
average <- ____(my_vector)
print(average)

# 5. Create a vector of species names
species <- c("____", "____", "____")

# 6. How many species?
n_species <- ____(species)
print(n_species)
```

<div class="hint">
<span class="en">Functions needed: `sum()`, `mean()`, `length()`</span>
<span class="de">Benotigte Funktionen: `sum()`, `mean()`, `length()`</span>
</div>

---

## <span class="en">Exercise 2: Working with Data</span><span class="de">Ubung 2: Mit Daten arbeiten</span>

<div class="en">

**Task:** Explore data structure and access columns.

</div>

<div class="de">

**Aufgabe:** Datenstruktur erkunden und auf Spalten zugreifen.

</div>

```{r}
# Exercise 2: Working with Data

# Create example data
plants <- data.frame(
 species = c("Quercus robur", "Fagus sylvatica", "Pinus sylvestris",
             "Betula pendula", "Acer pseudoplatanus"),
 height = c(25, 30, 20, 18, 22),
 native = c(TRUE, TRUE, TRUE, TRUE, TRUE)
)

# 1. View first rows
____(plants)

# 2. Check structure
____(plants)

# 3. How many rows?
____(plants)

# 4. Column names
____(plants)

# 5. Access the height column
plants$____

# 6. Mean height
mean(plants$____)

# 7. Tallest tree
max(plants$____)
```

<div class="hint">
<span class="en">Functions needed: `head()`, `str()`, `nrow()`, `names()`</span>
<span class="de">Benotigte Funktionen: `head()`, `str()`, `nrow()`, `names()`</span>
</div>

---

## <span class="en">Exercise 3: Unique Species</span><span class="de">Ubung 3: Einzigartige Arten</span>

<div class="en">

**Task:** Practice with `unique()` - the key function for accumulation curves!

</div>

<div class="de">

**Aufgabe:** Ube mit `unique()` - die Schlusselfunktion fur Akkumulationskurven!

</div>

```{r}
# Exercise 3: Unique Species

# Species found in different plots
plot1 <- c("Oak", "Beech", "Pine")
plot2 <- c("Beech", "Maple", "Oak")
plot3 <- c("Pine", "Birch", "Oak")

# 1. Combine all species
all_species <- c(____, ____, ____)

# 2. How many total observations?
length(____)

# 3. How many UNIQUE species?
unique_species <- ____(____)
length(____)

# 4. What are the unique species?
print(____)

# 5. Cumulative count: After plot 1
after_plot1 <- length(unique(____))

# 6. After plots 1 and 2
after_plot2 <- length(unique(c(____, ____)))

# 7. After all plots
after_plot3 <- length(unique(c(____, ____, ____)))

print(c(after_plot1, after_plot2, after_plot3))
```

<div class="hint">
<span class="en">Key function: `unique()` returns only distinct values</span>
<span class="de">Schlusselfunktion: `unique()` gibt nur eindeutige Werte zuruck</span>
</div>

---

# <span class="en">Part 2: Loops and Filtering</span><span class="de">Teil 2: Schleifen und Filtern</span>

## <span class="en">Exercise 4: For Loops</span><span class="de">Ubung 4: For-Schleifen</span>

<div class="en">

**Task:** Practice writing for loops - essential for building accumulation curves!

</div>

<div class="de">

**Aufgabe:** Ube das Schreiben von for-Schleifen - essentiell fur Akkumulationskurven!

</div>

```{r}
# Exercise 4: For Loops

# 1. Print numbers 1 to 5
for (i in ____) {
 print(____)
}

# 2. Calculate sum of 1 to 100
total <- 0
for (i in 1:100) {
 total <- total + ____
}
print(total)  # Should be 5050

# 3. Build a vector of squares
squares <- c()
for (i in 1:10) {
 squares[i] <- ____
}
print(squares)

# 4. Iterate over species names
species <- c("Oak", "Beech", "Pine", "Maple")
for (sp in ____) {
 print(paste("Found:", ____))
}

# 5. Count items matching a condition
values <- c(3, 7, 2, 9, 4, 6, 8, 1)
count_above_5 <- 0
for (v in values) {
 if (v ____ 5) {
   count_above_5 <- count_above_5 + ____
 }
}
print(count_above_5)  # Should be 4
```

<div class="hint">
<span class="en">Loop syntax: `for (i in 1:n) { ... }` or `for (item in vector) { ... }`</span>
<span class="de">Schleifen-Syntax: `for (i in 1:n) { ... }` oder `for (item in vector) { ... }`</span>
</div>

---

## <span class="en">Exercise 5: Filtering Data</span><span class="de">Ubung 5: Daten filtern</span>

<div class="en">

**Task:** Filter data by conditions - crucial for separating native and alien species!

</div>

<div class="de">

**Aufgabe:** Filtere Daten nach Bedingungen - wichtig um heimische und Alien-Arten zu trennen!

</div>

```{r}
# Exercise 5: Filtering Data

# Create example data
flora <- data.frame(
 species = c("Fagus sylvatica", "Impatiens glandulifera",
             "Quercus robur", "Solidago canadensis",
             "Pinus sylvestris", "Reynoutria japonica"),
 status = c("native", "alien", "native", "alien", "native", "alien"),
 n_plots = c(450, 120, 380, 95, 200, 45),
 cover = c(45, 15, 35, 20, 30, 25)
)

# 1. Filter only native species
native_only <- flora[flora$status == ____, ]
print(native_only)

# 2. Filter only alien species
alien_only <- flora[flora$____ == "alien", ]
print(alien_only)

# 3. Species with more than 100 plots
common <- flora[flora$n_plots ____ 100, ]
print(common)

# 4. Native AND common (>200 plots)
native_common <- flora[flora$status == "native" ____ flora$n_plots > 200, ]
print(native_common)

# 5. Using subset() function
rare_aliens <- subset(flora, status == ____ & n_plots ____ 100)
print(rare_aliens)

# 6. Count species per status
n_native <- nrow(flora[flora$status == ____, ])
n_alien <- nrow(flora[flora$status == ____, ])
print(paste("Native:", n_native, "Alien:", n_alien))
```

<div class="hint">
<span class="en">Operators: `==` (equals), `>` (greater), `&` (AND), `|` (OR)</span>
<span class="de">Operatoren: `==` (gleich), `>` (grosser), `&` (UND), `|` (ODER)</span>
</div>

---

## <span class="en">Exercise 6: Distance Calculation</span><span class="de">Ubung 6: Distanzberechnung</span>

<div class="en">

**Task:** Calculate Euclidean distance - needed for the nearest neighbour algorithm!

**Formula:** $d = \sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}$

</div>

<div class="de">

**Aufgabe:** Berechne euklidische Distanz - benotigt fur den Nearest-Neighbour-Algorithmus!

**Formel:** $d = \sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}$

</div>

```{r}
# Exercise 6: Distance Calculation

# 1. Distance between two points
point_a <- c(x = 0, y = 0)
point_b <- c(x = 3, y = 4)

distance <- sqrt((point_b["x"] - point_a["x"])^____ +
                (point_b["y"] - point_a["y"])^____)
print(distance)  # Should be 5

# 2. Which plot is nearest?
current <- c(x = 100, y = 100)

candidates <- data.frame(
 plot_id = c("A", "B", "C", "D"),
 x = c(110, 95, 150, 102),
 y = c(105, 90, 120, 98)
)

# Calculate distance to each candidate
candidates$distance <- sqrt(
 (candidates$x - current["x"])^2 +
 (candidates$y - current["y"])^2
)

print(candidates)

# 3. Find the nearest plot
nearest_idx <- which.____(candidates$distance)
nearest_plot <- candidates$plot_id[____]
print(paste("Nearest plot:", nearest_plot))

# 4. Get the full row of nearest plot
nearest <- candidates[which.min(candidates$____), ]
print(nearest)
```

<div class="hint">
<span class="en">`which.min()` returns the index of the minimum value</span>
<span class="de">`which.min()` gibt den Index des Minimums zuruck</span>
</div>

---

## <span class="en">Exercise 7: Cumulative Sums</span><span class="de">Ubung 7: Kumulative Summen</span>

<div class="en">

**Task:** Practice cumulative calculations - the core of accumulation curves!

</div>

<div class="de">

**Aufgabe:** Ube kumulative Berechnungen - der Kern von Akkumulationskurven!

</div>

```{r}
# Exercise 7: Cumulative Sums

# New species found per plot
new_species <- c(15, 8, 5, 3, 2, 2, 1, 1, 0, 1)

# 1. Using cumsum() - the easy way!
cumulative <- ____(new_species)
print(cumulative)

# 2. Manual loop - understand how it works
cumulative_manual <- numeric(length(new_species))
running_total <- 0

for (i in 1:length(new_species)) {
 running_total <- running_total + new_species[____]
 cumulative_manual[i] <- ____
}
print(cumulative_manual)

# 3. At which plot did we reach 30 species?
plot_at_30 <- which(cumulative >= ____)[1]
print(paste("Reached 30 species at plot:", plot_at_30))

# 4. Total species after 5 plots?
species_after_5 <- cumulative[____]
print(paste("Species after 5 plots:", species_after_5))

# 5. Species discovered in last 5 plots?
last_5_new <- sum(new_species[____:____])
print(paste("New species in last 5 plots:", last_5_new))
```

<div class="hint">
<span class="en">`cumsum()` calculates running totals: cumsum(c(1,2,3)) = c(1,3,6)</span>
<span class="de">`cumsum()` berechnet laufende Summen: cumsum(c(1,2,3)) = c(1,3,6)</span>
</div>

---

## <span class="en">Exercise 8: Building an Accumulation Curve</span><span class="de">Ubung 8: Eine Akkumulationskurve bauen</span>

<div class="en">

**Task:** Combine everything to build a complete accumulation curve!

</div>

<div class="de">

**Aufgabe:** Kombiniere alles um eine komplette Akkumulationskurve zu bauen!

</div>

```{r}
# Exercise 8: Building an Accumulation Curve

# Species lists for 5 plots
plot_species <- list(
 c("Oak", "Beech", "Pine"),
 c("Beech", "Maple", "Birch", "Pine"),
 c("Oak", "Linden", "Beech"),
 c("Spruce", "Pine", "Oak"),
 c("Maple", "Ash", "Beech", "Elm")
)

# Initialize tracking variables
found_species <- c()
cumulative_count <- numeric(5)

# Loop through each plot
for (i in 1:5) {
 # Get species in current plot
 current_species <- plot_species[[____]]

 # Find NEW species (not seen before)
 new_species <- setdiff(____, ____)

 # Add to found species
 found_species <- c(found_species, ____)

 # Record cumulative count
 cumulative_count[i] <- length(____)

 # Print progress
 cat("Plot", i, "- New:", length(new_species),
     "- Total:", cumulative_count[i], "\n")
}

# Final result
print(cumulative_count)
print(paste("Total unique species:", length(found_species)))
```

<div class="hint">
<span class="en">`setdiff(a, b)` returns elements in a that are NOT in b</span>
<span class="de">`setdiff(a, b)` gibt Elemente in a zuruck, die NICHT in b sind</span>
</div>

---

# <span class="en">Part 3: Functions and Plotting</span><span class="de">Teil 3: Funktionen und Plotting</span>

## <span class="en">Exercise 9: Writing Functions</span><span class="de">Ubung 9: Funktionen schreiben</span>

<div class="en">

**Task:** Create reusable functions for your analysis!

</div>

<div class="de">

**Aufgabe:** Erstelle wiederverwendbare Funktionen fur deine Analyse!

</div>

```{r}
# Exercise 9: Writing Functions

# 1. Simple function: Calculate area of rectangle
rectangle_area <- function(length, width) {
 area <- ____ * ____
 return(____)
}

# Test it
rectangle_area(5, 10)  # Should be 50

# 2. Function with default argument
greet <- function(name, language = "en") {
 if (language == "en") {
   return(paste("Hello", ____))
 } else if (language == "de") {
   return(paste("Hallo", ____))
 }
}

greet("Anna")              # "Hello Anna"
greet("Anna", "de")        # "Hallo Anna"

# 3. Function returning multiple values
summarize_vector <- function(x) {
 return(list(
   mean = ____(x),
   min = ____(x),
   max = ____(x),
   n = ____(x)
 ))
}

result <- summarize_vector(c(10, 20, 30, 40, 50))
print(result$mean)  # 30

# 4. Function for species richness
count_unique <- function(species_vector) {
 unique_species <- ____(____)
 return(length(____))
}

count_unique(c("Oak", "Beech", "Oak", "Pine"))  # Should be 3
```

<div class="hint">
<span class="en">Function syntax: `function_name <- function(arg1, arg2) { ... return(result) }`</span>
<span class="de">Funktions-Syntax: `function_name <- function(arg1, arg2) { ... return(result) }`</span>
</div>

---

## <span class="en">Exercise 10: Plotting with ggplot2</span><span class="de">Ubung 10: Plotten mit ggplot2</span>

<div class="en">

**Task:** Create publication-ready plots of accumulation curves!

</div>

<div class="de">

**Aufgabe:** Erstelle publikationsreife Plots von Akkumulationskurven!

</div>

```{r}
# Exercise 10: Plotting with ggplot2

library(ggplot2)

# Create example data
curve_data <- data.frame(
 plots = 1:20,
 species = cumsum(c(15, 8, 5, 4, 3, 3, 2, 2, 2, 1,
                    1, 1, 1, 1, 0, 1, 0, 0, 1, 0))
)

# 1. Basic line plot
ggplot(curve_data, aes(x = ____, y = ____)) +
 geom_line()

# 2. Add points and styling
ggplot(curve_data, aes(x = plots, y = species)) +
 geom_line(color = "____", linewidth = ____) +
 geom_point(color = "____", size = ____)

# 3. Add labels and theme
ggplot(curve_data, aes(x = plots, y = species)) +
 geom_line(color = "darkgreen", linewidth = 1.5) +
 labs(
   title = "____",
   x = "____",
   y = "____"
 ) +
 theme_minimal()

# 4. Two groups comparison
comparison_data <- data.frame(
 plots = rep(1:20, 2),
 species = c(
   cumsum(c(20, 10, 6, 4, 3, 2, 2, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0)),
   cumsum(c(8, 5, 3, 2, 2, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0))
 ),
 status = rep(c("Native", "Alien"), each = 20)
)

ggplot(comparison_data, aes(x = plots, y = species, color = ____)) +
 geom_line(linewidth = 1.5) +
 scale_color_manual(values = c("Native" = "____", "Alien" = "____")) +
 labs(
   title = "Species Accumulation: Native vs. Alien",
   x = "Number of Plots",
   y = "Cumulative Species",
   color = "Status"
 ) +
 theme_minimal() +
 theme(legend.position = "____")
```

<div class="hint">
<span class="en">ggplot structure: `ggplot(data, aes(x, y)) + geom_*() + labs() + theme_*()`</span>
<span class="de">ggplot Struktur: `ggplot(data, aes(x, y)) + geom_*() + labs() + theme_*()`</span>
</div>

---

## <span class="en">Exercise 11: Confidence Intervals</span><span class="de">Ubung 11: Konfidenzintervalle</span>

<div class="en">

**Task:** Add confidence bands to show uncertainty!

</div>

<div class="de">

**Aufgabe:** Fuge Konfidenzbander hinzu um Unsicherheit zu zeigen!

</div>

```{r}
# Exercise 11: Confidence Intervals

library(ggplot2)

# Data with confidence intervals
set.seed(42)
ci_data <- data.frame(
 plots = 1:30,
 mean_species = cumsum(c(25, rpois(29, 4)))
)
ci_data$ci_lower <- ci_data$mean_species - runif(30, 2, 8)
ci_data$ci_upper <- ci_data$mean_species + runif(30, 2, 8)

# Plot with ribbon for CI
ggplot(ci_data, aes(x = ____)) +
 geom_ribbon(
   aes(ymin = ____, ymax = ____),
   fill = "darkgreen",
   alpha = ____
 ) +
 geom_line(
   aes(y = ____),
   color = "darkgreen",
   linewidth = ____
 ) +
 labs(
   title = "Accumulation Curve with 95% CI",
   subtitle = "Shaded area shows uncertainty",
   x = "Plots Sampled",
   y = "Species Count"
 ) +
 theme_minimal()
```

<div class="hint">
<span class="en">`geom_ribbon()` creates shaded bands; use `alpha` for transparency (0-1)</span>
<span class="de">`geom_ribbon()` erstellt schattierte Bander; `alpha` fur Transparenz (0-1)</span>
</div>

---

# <span class="en">Part 4: Real Data Analysis</span><span class="de">Teil 4: Echte Datenanalyse</span>

<div class="en">

**Austrian Vegetation Data:** For the following exercises, we'll use real vegetation plot data from Austria containing over 15,000 plots with native and alien plant species.

</div>

<div class="de">

**Osterreichische Vegetationsdaten:** Fur die folgenden Ubungen verwenden wir echte Vegetationsplotdaten aus Osterreich mit uber 15.000 Plots mit heimischen und Alien-Pflanzenarten.

</div>

## <span class="en">Exercise 12: Load and Explore</span><span class="de">Ubung 12: Laden und Erkunden</span>

<div class="en">

**Task:** Load the Austrian vegetation data and explore its structure.

</div>

<div class="de">

**Aufgabe:** Lade die osterreichischen Vegetationsdaten und erkunde ihre Struktur.

</div>

```{r}
# Exercise 12: Load and Explore Austrian Data

# Load the data
header <- read.csv("../data/austria_header.csv")
species <- read.csv("../data/austria_species.csv")

# 1. How many plots?
n_plots <- ____(header)
print(paste("Number of plots:", n_plots))

# 2. How many species records?
n_records <- ____(species)
print(paste("Species records:", n_records))

# 3. How many unique species?
n_species <- length(____(species$WFO_TAXON))
print(paste("Unique species:", n_species))

# 4. Count native vs alien species
table(species$____)

# 5. What proportion are aliens?
n_alien <- sum(species$STATUS == "____")
n_native <- sum(species$STATUS == "____")
prop_alien <- n_alien / (n_alien + n_native)
print(paste("Proportion alien:", round(prop_alien, ____)))

# 6. Which families have the most alien species?
alien_species <- species[species$STATUS == "alien", ]
family_counts <- table(alien_species$____)
head(sort(family_counts, decreasing = ____), 10)

# 7. Year range of the data
range(header$____)
```

<div class="hint">
<span class="en">Functions: `nrow()`, `unique()`, `table()`, `sort()`</span>
<span class="de">Funktionen: `nrow()`, `unique()`, `table()`, `sort()`</span>
</div>

---

## <span class="en">Exercise 13: Merge and Prepare</span><span class="de">Ubung 13: Zusammenfuhren und Vorbereiten</span>

<div class="en">

**Task:** Merge plot coordinates with species data for spatial analysis.

</div>

<div class="de">

**Aufgabe:** Verbinde Plotkoordinaten mit Artdaten fur raumliche Analyse.

</div>

```{r}
# Exercise 13: Merge and Prepare Data

library(dplyr)

# Merge species with plot coordinates
full_data <- merge(species, header, by = "____")

# Check the merge worked
head(full_data)
nrow(full_data)  # Should equal nrow(species)

# Create separate datasets for native and alien species
native_data <- full_data %>%
  filter(STATUS == "____")

alien_data <- full_data %>%
  filter(STATUS == "____")

print(paste("Native records:", ____(native_data)))
print(paste("Alien records:", ____(alien_data)))

# How many unique alien species?
n_alien_species <- length(unique(____$WFO_TAXON))
print(paste("Unique alien species:", n_alien_species))

# How many unique native species?
n_native_species <- length(unique(____$WFO_TAXON))
print(paste("Unique native species:", n_native_species))

# Get unique plots with coordinates
plot_coords <- header %>%
  select(PlotObservationID, ____, ____) %>%
  distinct()

head(plot_coords)
```

<div class="hint">
<span class="en">`merge()` joins data frames by common columns; `dplyr::filter()` subsets rows</span>
<span class="de">`merge()` verbindet Datensatze uber gemeinsame Spalten; `dplyr::filter()` wahlt Zeilen aus</span>
</div>

---

## <span class="en">Exercise 14: Simple Accumulation Curve</span><span class="de">Ubung 14: Einfache Akkumulationskurve</span>

<div class="en">

**Task:** Build a species accumulation curve using random plot order.

</div>

<div class="de">

**Aufgabe:** Erstelle eine Artenakkumulationskurve mit zufalliger Plotreihenfolge.

</div>

```{r}
# Exercise 14: Simple Accumulation Curve

# Get unique plot IDs
plot_ids <- unique(header$PlotObservationID)
n_plots <- length(plot_ids)

# Shuffle plot order randomly
set.seed(42)  # For reproducibility
shuffled_plots <- sample(____, n_plots)

# Build accumulation curve
found_species <- c()
accumulation <- numeric(n_plots)

for (i in 1:n_plots) {
  # Get current plot ID
  current_plot <- shuffled_plots[____]

  # Get species in this plot
  plot_species <- species %>%
    filter(PlotObservationID == ____) %>%
    pull(WFO_TAXON) %>%
    unique()

  # Add new species to found list
  new_species <- setdiff(____, ____)
  found_species <- c(found_species, ____)

  # Record cumulative count
  accumulation[i] <- length(____)

  # Print progress every 1000 plots
  if (i %% 1000 == 0) {
    cat("Plot", i, "- Total species:", accumulation[i], "\n")
  }
}

# Plot the curve
plot(1:n_plots, ____, type = "l",
     xlab = "Number of plots",
     ylab = "Cumulative species",
     main = "Species Accumulation Curve - Austria")
```

<div class="hint">
<span class="en">`sample()` randomly shuffles; `setdiff(new, found)` returns only new species</span>
<span class="de">`sample()` mischt zufallig; `setdiff(new, found)` gibt nur neue Arten zuruck</span>
</div>

---

## <span class="en">Exercise 15: Native vs Alien Comparison</span><span class="de">Ubung 15: Heimisch vs. Alien Vergleich</span>

<div class="en">

**Task:** Compare accumulation curves for native and alien species.

</div>

<div class="de">

**Aufgabe:** Vergleiche Akkumulationskurven fur heimische und Alien-Arten.

</div>

```{r}
# Exercise 15: Native vs Alien Comparison

library(ggplot2)

# Use same plot order for both
set.seed(42)
plot_ids <- unique(header$PlotObservationID)
shuffled_plots <- sample(plot_ids, length(plot_ids))
n_plots <- length(shuffled_plots)

# Function to build accumulation for a subset
build_accumulation <- function(species_data, plot_order) {
  found <- c()
  accum <- numeric(length(plot_order))

  for (i in seq_along(plot_order)) {
    plot_sp <- species_data %>%
      filter(PlotObservationID == plot_order[i]) %>%
      pull(WFO_TAXON) %>%
      unique()

    new_sp <- setdiff(plot_sp, ____)
    found <- c(found, new_sp)
    accum[i] <- length(____)
  }
  return(accum)
}

# Build curves for native and alien separately
native_accum <- build_accumulation(
  species %>% filter(STATUS == "____"),
  shuffled_plots
)

alien_accum <- build_accumulation(
  species %>% filter(STATUS == "____"),
  shuffled_plots
)

# Create data frame for plotting
curve_data <- data.frame(
  plots = rep(1:n_plots, ____),
  species = c(native_accum, ____),
  status = rep(c("Native", "Alien"), each = ____)
)

# Plot comparison
ggplot(curve_data, aes(x = plots, y = species, color = ____)) +
  geom_line(linewidth = 1) +
  scale_color_manual(values = c("Native" = "____", "Alien" = "____")) +
  labs(
    title = "Species Accumulation: Native vs. Alien",
    subtitle = "Austrian vegetation plots",
    x = "Number of Plots",
    y = "Cumulative Species",
    color = "Status"
  ) +
  theme_minimal() +
  theme(legend.position = "____")
```

<div class="hint">
<span class="en">Use the same shuffled plot order for both groups to make them comparable</span>
<span class="de">Verwende die gleiche Plotreihenfolge fur beide Gruppen zur Vergleichbarkeit</span>
</div>

---

## <span class="en">Exercise 16: Bootstrapping for Confidence Intervals</span><span class="de">Ubung 16: Bootstrapping fur Konfidenzintervalle</span>

<div class="en">

**Task:** Use bootstrapping to estimate uncertainty in accumulation curves.

</div>

<div class="de">

**Aufgabe:** Verwende Bootstrapping um Unsicherheit in Akkumulationskurven zu schatzen.

</div>

```{r}
# Exercise 16: Bootstrapping Confidence Intervals

library(dplyr)
library(ggplot2)

# Simplified: work with a random subset of plots for speed
set.seed(42)
sample_plots <- sample(unique(header$PlotObservationID), 500)
sample_species <- species %>%
  filter(PlotObservationID %in% sample_plots)

# Function to calculate one accumulation run
one_accumulation_run <- function(species_data, status_filter = NULL) {
  if (!is.null(status_filter)) {
    species_data <- species_data %>% filter(STATUS == status_filter)
  }

  plot_ids <- unique(species_data$PlotObservationID)
  shuffled <- sample(plot_ids, length(plot_ids))

  found <- c()
  accum <- numeric(length(shuffled))

  for (i in seq_along(shuffled)) {
    plot_sp <- species_data %>%
      filter(PlotObservationID == shuffled[i]) %>%
      pull(WFO_TAXON) %>%
      unique()

    new_sp <- setdiff(plot_sp, found)
    found <- c(found, new_sp)
    accum[i] <- length(found)
  }
  return(accum)
}

# Run multiple bootstrap iterations
n_bootstrap <- ____  # Start with 50 for testing
n_plots <- length(sample_plots)

# Store results
all_runs <- matrix(NA, nrow = n_bootstrap, ncol = n_plots)

for (b in 1:n_bootstrap) {
  all_runs[b, ] <- one_accumulation_run(sample_species)
  if (b %% 10 == 0) cat("Bootstrap iteration:", b, "\n")
}

# Calculate mean and confidence intervals
mean_curve <- ____(all_runs, 2, mean)  # apply mean to each column
ci_lower <- apply(all_runs, 2, function(x) quantile(x, ____))
ci_upper <- apply(all_runs, 2, function(x) quantile(x, ____))

# Create summary data frame
boot_summary <- data.frame(
  plots = 1:n_plots,
  mean_species = mean_curve,
  ci_lower = ____,
  ci_upper = ____
)

# Plot with confidence ribbon
ggplot(boot_summary, aes(x = ____)) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper),
              fill = "darkgreen", alpha = ____) +
  geom_line(aes(y = mean_species),
            color = "darkgreen", linewidth = ____) +
  labs(
    title = "Bootstrapped Species Accumulation",
    subtitle = paste(n_bootstrap, "iterations, 95% CI"),
    x = "Number of Plots",
    y = "Cumulative Species"
  ) +
  theme_minimal()
```

<div class="hint">
<span class="en">`apply(matrix, 2, function)` applies function to each column; quantile(x, 0.025) for 2.5th percentile</span>
<span class="de">`apply(matrix, 2, function)` wendet Funktion auf jede Spalte an; quantile(x, 0.025) fur 2.5. Perzentil</span>
</div>

---

## <span class="en">Exercise 17: Nearest Neighbour Accumulation</span><span class="de">Ubung 17: Nearest-Neighbour Akkumulation</span>

<div class="en">

**Task:** Build accumulation curves using spatially ordered plots (nearest neighbour algorithm).

</div>

<div class="de">

**Aufgabe:** Erstelle Akkumulationskurven mit raumlich geordneten Plots (Nearest-Neighbour-Algorithmus).

</div>

```{r}
# Exercise 17: Nearest Neighbour Accumulation

library(dplyr)

# Work with subset for speed
set.seed(42)
sample_plots <- sample(unique(header$PlotObservationID), 300)
sample_header <- header %>% filter(PlotObservationID %in% sample_plots)
sample_species <- species %>% filter(PlotObservationID %in% sample_plots)

# Function: calculate distance between two points
calc_distance <- function(x1, y1, x2, y2) {
  sqrt((x2 - x1)^____ + (y2 - y1)^____)
}

# Nearest neighbour walk function
nn_accumulation <- function(header_data, species_data, start_idx = NULL) {
  n <- nrow(header_data)

  # Random start if not specified
  if (is.null(start_idx)) {
    start_idx <- sample(1:n, ____)
  }

  visited <- rep(____, n)  # Track visited plots
  visit_order <- numeric(n)
  found_species <- c()
  accumulation <- numeric(n)

  current_idx <- start_idx

  for (i in 1:n) {
    # Mark current as visited
    visited[current_idx] <- ____
    visit_order[i] <- header_data$PlotObservationID[current_idx]

    # Get species in current plot
    plot_sp <- species_data %>%
      filter(PlotObservationID == visit_order[i]) %>%
      pull(WFO_TAXON) %>%
      unique()

    # Update accumulation
    new_sp <- setdiff(plot_sp, ____)
    found_species <- c(found_species, new_sp)
    accumulation[i] <- length(found_species)

    # Find nearest unvisited plot
    if (i < n) {
      current_x <- header_data$Longitude[current_idx]
      current_y <- header_data$Latitude[current_idx]

      # Calculate distances to all unvisited plots
      distances <- calc_distance(
        current_x, current_y,
        header_data$____, header_data$____
      )

      # Set visited plots to Inf so they won't be chosen
      distances[visited] <- ____

      # Select nearest
      current_idx <- which.____(distances)
    }
  }

  return(accumulation)
}

# Run the nearest neighbour accumulation
nn_curve <- nn_accumulation(sample_header, sample_species)

# Compare with random order
random_curve <- one_accumulation_run(sample_species)

# Plot comparison
comparison <- data.frame(
  plots = rep(1:length(nn_curve), 2),
  species = c(nn_curve, random_curve),
  method = rep(c("Nearest Neighbour", "Random"), each = length(nn_curve))
)

ggplot(comparison, aes(x = plots, y = species, color = ____)) +
  geom_line(linewidth = 1) +
  scale_color_manual(values = c("Nearest Neighbour" = "blue",
                                "Random" = "____")) +
  labs(
    title = "Accumulation Curve Comparison",
    subtitle = "Spatial vs. random plot ordering",
    x = "Number of Plots",
    y = "Cumulative Species"
  ) +
  theme_minimal()
```

<div class="hint">
<span class="en">Nearest neighbour curves typically accumulate species slower (spatially clustered plots share species)</span>
<span class="de">Nearest-Neighbour-Kurven akkumulieren Arten typischerweise langsamer (raumlich geclusterte Plots teilen Arten)</span>
</div>

---

## <span class="en">Exercise 18: Habitat Comparison</span><span class="de">Ubung 18: Habitatvergleich</span>

<div class="en">

**Task:** Compare accumulation curves across different EUNIS habitat types.

</div>

<div class="de">

**Aufgabe:** Vergleiche Akkumulationskurven uber verschiedene EUNIS-Habitattypen.

</div>

```{r}
# Exercise 18: Habitat Comparison

library(dplyr)
library(ggplot2)

# Check available habitat types
table(header$Eunis_lvl1)

# Merge species with header to get habitat info
full_data <- merge(species, header, by = "PlotObservationID")

# Function to build accumulation for a habitat subset
habitat_accumulation <- function(data, habitat_code, n_plots_max = 200) {
  habitat_data <- data %>%
    filter(Eunis_lvl1 == habitat_code)

  plot_ids <- unique(habitat_data$PlotObservationID)

  # Limit number of plots
  if (length(plot_ids) > n_plots_max) {
    plot_ids <- sample(plot_ids, n_plots_max)
  }

  shuffled <- sample(plot_ids, length(plot_ids))
  found <- c()
  accum <- numeric(length(shuffled))

  for (i in seq_along(shuffled)) {
    plot_sp <- habitat_data %>%
      filter(PlotObservationID == shuffled[i]) %>%
      pull(WFO_TAXON) %>%
      unique()

    new_sp <- setdiff(plot_sp, found)
    found <- c(____, new_sp)
    accum[i] <- length(____)
  }

  return(data.frame(
    plots = 1:length(accum),
    species = accum,
    habitat = habitat_code
  ))
}

# Build curves for different habitats
set.seed(42)
habitat_codes <- c("R", "T", "S")  # Grasslands, Forests, Shrubs
habitat_names <- c("R" = "Grassland", "T" = "Forest", "S" = "Shrub")

all_curves <- data.frame()
for (hab in habitat_codes) {
  curve <- habitat_accumulation(full_data, ____, n_plots_max = 300)
  all_curves <- rbind(all_curves, ____)
}

# Rename habitats for plotting
all_curves$habitat_name <- habitat_names[all_curves$____]

# Plot
ggplot(all_curves, aes(x = plots, y = species, color = ____)) +
  geom_line(linewidth = 1.2) +
  labs(
    title = "Species Accumulation by Habitat Type",
    subtitle = "Austrian vegetation plots",
    x = "Number of Plots",
    y = "Cumulative Species",
    color = "Habitat"
  ) +
  theme_minimal() +
  theme(legend.position = "____")
```

<div class="hint">
<span class="en">EUNIS codes: R = grasslands, T = forests, S = shrubs, N = coastal, Q = wetlands</span>
<span class="de">EUNIS-Codes: R = Grasland, T = Wald, S = Gebusch, N = Kustenlebensraum, Q = Feuchtgebiete</span>
</div>

---

## <span class="en">Exercise 19: Estimating Total Richness</span><span class="de">Ubung 19: Gesamtreichtum schatzen</span>

<div class="en">

**Task:** Use extrapolation methods to estimate total species richness from accumulation curves.

</div>

<div class="de">

**Aufgabe:** Verwende Extrapolationsmethoden um den Gesamtartenreichtum aus Akkumulationskurven zu schatzen.

</div>

```{r}
# Exercise 19: Estimating Total Richness

# Chao1 estimator: estimates true richness from observed data
# Formula: S_chao = S_obs + (f1^2 / (2 * f2))
# where f1 = singletons (species in 1 plot), f2 = doubletons (species in 2 plots)

library(dplyr)

# Calculate species frequencies (how many plots each species occurs in)
species_freq <- species %>%
  group_by(WFO_TAXON) %>%
  summarise(n_plots = n_distinct(PlotObservationID), .groups = "drop")

# Observed richness
S_obs <- nrow(species_freq)
print(paste("Observed species:", ____))

# Count singletons (f1) and doubletons (f2)
f1 <- sum(species_freq$n_plots == ____)  # Species in exactly 1 plot
f2 <- sum(species_freq$n_plots == ____)  # Species in exactly 2 plots

print(paste("Singletons (f1):", f1))
print(paste("Doubletons (f2):", f2))

# Chao1 estimator
# Be careful: if f2 = 0, use modified formula
if (f2 > 0) {
  S_chao <- S_obs + (f1^____ / (2 * ____))
} else {
  S_chao <- S_obs + (f1 * (f1 - 1) / 2)
}

print(paste("Chao1 estimate:", round(S_chao, 0)))
print(paste("Estimated unseen species:", round(____ - S_obs, 0)))

# What percentage have we observed?
coverage <- (S_obs / S_chao) * 100
print(paste("Sample coverage:", round(____, 1), "%"))

# Apply same analysis to alien species only
alien_freq <- species %>%
  filter(STATUS == "____") %>%
  group_by(WFO_TAXON) %>%
  summarise(n_plots = n_distinct(PlotObservationID), .groups = "drop")

S_obs_alien <- nrow(alien_freq)
f1_alien <- sum(alien_freq$n_plots == 1)
f2_alien <- sum(alien_freq$n_plots == 2)

if (f2_alien > 0) {
  S_chao_alien <- S_obs_alien + (f1_alien^2 / (2 * f2_alien))
} else {
  S_chao_alien <- S_obs_alien + (f1_alien * (f1_alien - 1) / 2)
}

print(paste("Alien species observed:", S_obs_alien))
print(paste("Alien species estimated (Chao1):", round(____, 0)))
```

<div class="hint">
<span class="en">Chao1 uses rare species counts to estimate unobserved species; high f1 = many unseen species likely</span>
<span class="de">Chao1 nutzt seltene Artenzahlen um unbeobachtete Arten zu schatzen; hohes f1 = wahrscheinlich viele ungesehene Arten</span>
</div>

---

## <span class="en">Exercise 20: Final Challenge - Complete Pipeline</span><span class="de">Ubung 20: Finale Herausforderung - Komplette Pipeline</span>

<div class="en">

**Task:** Combine everything into a publication-ready analysis comparing native and alien accumulation with bootstrapped confidence intervals.

</div>

<div class="de">

**Aufgabe:** Kombiniere alles zu einer publikationsreifen Analyse, die heimische und Alien-Akkumulation mit Bootstrapping-Konfidenzintervallen vergleicht.

</div>

```{r}
# Exercise 20: Complete Analysis Pipeline

library(dplyr)
library(ggplot2)

# Parameters
n_bootstrap <- 50
n_sample_plots <- 500

# Sample plots for manageable runtime
set.seed(42)
sample_plots <- sample(unique(header$PlotObservationID), n_sample_plots)
sample_species <- species %>%
  filter(PlotObservationID %in% sample_plots)

# Bootstrap function
bootstrap_accumulation <- function(species_data, status_filter, n_runs) {
  plot_ids <- unique(species_data$PlotObservationID)
  n_plots <- length(plot_ids)
  all_runs <- matrix(NA, nrow = n_runs, ncol = n_plots)

  filtered_data <- species_data %>%
    filter(STATUS == status_filter)

  for (b in 1:n_runs) {
    shuffled <- sample(plot_ids, n_plots)
    found <- c()

    for (i in seq_along(shuffled)) {
      plot_sp <- filtered_data %>%
        filter(PlotObservationID == shuffled[i]) %>%
        pull(WFO_TAXON) %>%
        unique()

      found <- unique(c(found, plot_sp))
      all_runs[b, i] <- length(found)
    }
  }

  data.frame(
    plots = 1:n_plots,
    mean = apply(all_runs, 2, ____),
    ci_lower = apply(all_runs, 2, function(x) quantile(x, ____)),
    ci_upper = apply(all_runs, 2, function(x) quantile(x, ____))
  )
}

# Run for both native and alien
cat("Bootstrapping native species...\n")
native_boot <- bootstrap_accumulation(sample_species, "____", n_bootstrap)
native_boot$status <- "Native"

cat("Bootstrapping alien species...\n")
alien_boot <- bootstrap_accumulation(sample_species, "____", n_bootstrap)
alien_boot$status <- "Alien"

# Combine
combined <- rbind(native_boot, alien_boot)

# Final publication-ready plot
p <- ggplot(combined, aes(x = plots)) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper, fill = ____),
              alpha = 0.3) +
  geom_line(aes(y = mean, color = status), linewidth = 1.2) +
  scale_color_manual(
    values = c("Native" = "____", "Alien" = "____"),
    name = "Status"
  ) +
  scale_fill_manual(
    values = c("Native" = "____", "Alien" = "____"),
    name = "Status"
  ) +
  labs(
    title = "Species Accumulation: Native vs. Alien Plants",
    subtitle = paste0("Austrian vegetation data (n=", n_sample_plots,
                      " plots, ", n_bootstrap, " bootstrap iterations)"),
    x = "Number of Plots Sampled",
    y = "Cumulative Species Richness",
    caption = "Shaded areas represent 95% confidence intervals"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = c(0.85, 0.25),
    legend.background = element_rect(fill = "white", color = "gray80"),
    plot.title = element_text(face = "____"),
    panel.grid.minor = element_blank()
  )

print(p)

# Save the plot
# ggsave("accumulation_comparison.png", p, width = 10, height = 7, dpi = 300)
```

<div class="hint">
<span class="en">For publication: use consistent colors, add CI explanation, cite data source</span>
<span class="de">Fur Publikation: konsistente Farben verwenden, CI erklaren, Datenquelle zitieren</span>
</div>

---

# <span class="en">Quick Reference</span><span class="de">Schnellreferenz</span>

<div class="en">

| Function | Purpose |
|----------|---------|
| `c()` | Combine values into vector |
| `length()` | Count elements |
| `unique()` | Get unique values |
| `setdiff(a, b)` | Elements in a but not in b |
| `cumsum()` | Cumulative sum |
| `sqrt()` | Square root |
| `which.min()` | Index of minimum |
| `subset()` | Filter data |
| `ggplot()` | Create plot |
| `geom_line()` | Add line |
| `geom_ribbon()` | Add confidence band |

</div>

<div class="de">

| Funktion | Zweck |
|----------|-------|
| `c()` | Werte zu Vektor kombinieren |
| `length()` | Elemente zahlen |
| `unique()` | Einzigartige Werte |
| `setdiff(a, b)` | Elemente in a aber nicht in b |
| `cumsum()` | Kumulative Summe |
| `sqrt()` | Quadratwurzel |
| `which.min()` | Index des Minimums |
| `subset()` | Daten filtern |
| `ggplot()` | Plot erstellen |
| `geom_line()` | Linie hinzufugen |
| `geom_ribbon()` | Konfidenzband hinzufugen |

</div>
